/**
 * Generated by orval v7.6.0 üç∫
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { z as zod } from "zod";

/**
 * Create a flow run. If a flow run with the same flow_id and
idempotency key already exists, the existing flow run will be returned.

If no state is provided, the flow run will be created in a PENDING state.

For more information, see https://docs.prefect.io/v3/develop/write-flows.
 * @summary Create Flow Run
 */
export const createFlowRunFlowRunsPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const createFlowRunFlowRunsPostBodyStateStateDetailsDeferredDefault = false;
export const createFlowRunFlowRunsPostBodyStateStateDetailsUntrackableResultDefault = false;
export const createFlowRunFlowRunsPostBodyStateStateDetailsPauseRescheduleDefault = false;
export const createFlowRunFlowRunsPostBodyEmpiricalPolicyMaxRetriesDefault = 0;
export const createFlowRunFlowRunsPostBodyEmpiricalPolicyRetryDelaySecondsDefault = 0;
export const createFlowRunFlowRunsPostBodyEmpiricalPolicyResumingDefault = false;

export const createFlowRunFlowRunsPostBody = zod.object({
	state: zod
		.object({
			type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			name: zod.string().or(zod.null()).optional(),
			message: zod.string().or(zod.null()).optional(),
			data: zod.any().or(zod.null()).optional(),
			state_details: zod
				.object({
					flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					task_run_id: zod.string().uuid().or(zod.null()).optional(),
					child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					scheduled_time: zod.string().datetime().or(zod.null()).optional(),
					cache_key: zod.string().or(zod.null()).optional(),
					cache_expiration: zod.string().datetime().or(zod.null()).optional(),
					deferred: zod.boolean().or(zod.null()).optional(),
					untrackable_result: zod.boolean().optional(),
					pause_timeout: zod.string().datetime().or(zod.null()).optional(),
					pause_reschedule: zod.boolean().optional(),
					pause_key: zod.string().or(zod.null()).optional(),
					run_input_keyset: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
					refresh_cache: zod.boolean().or(zod.null()).optional(),
					retriable: zod.boolean().or(zod.null()).optional(),
					transition_id: zod.string().uuid().or(zod.null()).optional(),
					task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
					traceparent: zod.string().or(zod.null()).optional(),
				})
				.optional(),
		})
		.or(zod.null())
		.optional(),
	name: zod.string().optional(),
	flow_id: zod.string().uuid(),
	flow_version: zod.string().or(zod.null()).optional(),
	parameters: zod.object({}).optional(),
	context: zod.object({}).optional(),
	parent_task_run_id: zod.string().uuid().or(zod.null()).optional(),
	infrastructure_document_id: zod.string().uuid().or(zod.null()).optional(),
	empirical_policy: zod
		.object({
			max_retries: zod.number().optional(),
			retry_delay_seconds: zod.number().optional(),
			retries: zod.number().or(zod.null()).optional(),
			retry_delay: zod.number().or(zod.null()).optional(),
			pause_keys: zod.array(zod.string()).or(zod.null()).optional(),
			resuming: zod.boolean().or(zod.null()).optional(),
			retry_type: zod
				.enum(["in_process", "reschedule"])
				.or(zod.null())
				.optional(),
		})
		.optional(),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.or(zod.null())
		.optional(),
	idempotency_key: zod.string().or(zod.null()).optional(),
	deployment_id: zod.string().uuid().or(zod.null()).optional(),
});

export const createFlowRunFlowRunsPostResponseEmpiricalPolicyMaxRetriesDefault = 0;
export const createFlowRunFlowRunsPostResponseEmpiricalPolicyRetryDelaySecondsDefault = 0;
export const createFlowRunFlowRunsPostResponseEmpiricalPolicyResumingDefault = false;
export const createFlowRunFlowRunsPostResponseRunCountDefault = 0;
export const createFlowRunFlowRunsPostResponseTotalRunTimeDefault = 0;
export const createFlowRunFlowRunsPostResponseEstimatedRunTimeDefault = 0;
export const createFlowRunFlowRunsPostResponseEstimatedStartTimeDeltaDefault = 0;
export const createFlowRunFlowRunsPostResponseAutoScheduledDefault = false;
export const createFlowRunFlowRunsPostResponseStateStateDetailsDeferredDefault = false;
export const createFlowRunFlowRunsPostResponseStateStateDetailsUntrackableResultDefault = false;
export const createFlowRunFlowRunsPostResponseStateStateDetailsPauseRescheduleDefault = false;

export const createFlowRunFlowRunsPostResponse = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().optional(),
	flow_id: zod.string().uuid(),
	state_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_version: zod.string().or(zod.null()).optional(),
	work_queue_id: zod.string().uuid().or(zod.null()).optional(),
	work_queue_name: zod.string().or(zod.null()).optional(),
	flow_version: zod.string().or(zod.null()).optional(),
	parameters: zod.object({}).optional(),
	idempotency_key: zod.string().or(zod.null()).optional(),
	context: zod.object({}).optional(),
	empirical_policy: zod
		.object({
			max_retries: zod.number().optional(),
			retry_delay_seconds: zod.number().optional(),
			retries: zod.number().or(zod.null()).optional(),
			retry_delay: zod.number().or(zod.null()).optional(),
			pause_keys: zod.array(zod.string()).or(zod.null()).optional(),
			resuming: zod.boolean().or(zod.null()).optional(),
			retry_type: zod
				.enum(["in_process", "reschedule"])
				.or(zod.null())
				.optional(),
		})
		.optional(),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.optional(),
	parent_task_run_id: zod.string().uuid().or(zod.null()).optional(),
	state_type: zod
		.enum([
			"SCHEDULED",
			"PENDING",
			"RUNNING",
			"COMPLETED",
			"FAILED",
			"CANCELLED",
			"CRASHED",
			"PAUSED",
			"CANCELLING",
		])
		.or(zod.null())
		.optional(),
	state_name: zod.string().or(zod.null()).optional(),
	run_count: zod.number().optional(),
	expected_start_time: zod.string().datetime().or(zod.null()).optional(),
	next_scheduled_start_time: zod.string().datetime().or(zod.null()).optional(),
	start_time: zod.string().datetime().or(zod.null()).optional(),
	end_time: zod.string().datetime().or(zod.null()).optional(),
	total_run_time: zod.number().optional(),
	estimated_run_time: zod.number().optional(),
	estimated_start_time_delta: zod.number().optional(),
	auto_scheduled: zod.boolean().optional(),
	infrastructure_document_id: zod.string().uuid().or(zod.null()).optional(),
	infrastructure_pid: zod.string().or(zod.null()).optional(),
	created_by: zod
		.object({
			id: zod.string().uuid().or(zod.null()).optional(),
			type: zod.string().or(zod.null()).optional(),
			display_value: zod.string().or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
	work_pool_id: zod.string().uuid().or(zod.null()).optional(),
	work_pool_name: zod.string().or(zod.null()).optional(),
	state: zod
		.object({
			id: zod.string().uuid(),
			type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			name: zod.string().or(zod.null()).optional(),
			timestamp: zod.string().datetime().optional(),
			message: zod.string().or(zod.null()).optional(),
			data: zod.any().or(zod.null()).optional(),
			state_details: zod
				.object({
					flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					task_run_id: zod.string().uuid().or(zod.null()).optional(),
					child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					scheduled_time: zod.string().datetime().or(zod.null()).optional(),
					cache_key: zod.string().or(zod.null()).optional(),
					cache_expiration: zod.string().datetime().or(zod.null()).optional(),
					deferred: zod.boolean().or(zod.null()).optional(),
					untrackable_result: zod.boolean().optional(),
					pause_timeout: zod.string().datetime().or(zod.null()).optional(),
					pause_reschedule: zod.boolean().optional(),
					pause_key: zod.string().or(zod.null()).optional(),
					run_input_keyset: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
					refresh_cache: zod.boolean().or(zod.null()).optional(),
					retriable: zod.boolean().or(zod.null()).optional(),
					transition_id: zod.string().uuid().or(zod.null()).optional(),
					task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
					traceparent: zod.string().or(zod.null()).optional(),
				})
				.optional(),
		})
		.or(zod.null())
		.optional(),
	job_variables: zod.object({}).or(zod.null()).optional(),
});

/**
 * Updates a flow run.
 * @summary Update Flow Run
 */
export const updateFlowRunFlowRunsIdPatchParams = zod.object({
	id: zod.string().uuid(),
});

export const updateFlowRunFlowRunsIdPatchHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const updateFlowRunFlowRunsIdPatchBodyEmpiricalPolicyMaxRetriesDefault = 0;
export const updateFlowRunFlowRunsIdPatchBodyEmpiricalPolicyRetryDelaySecondsDefault = 0;
export const updateFlowRunFlowRunsIdPatchBodyEmpiricalPolicyResumingDefault = false;

export const updateFlowRunFlowRunsIdPatchBody = zod.object({
	name: zod.string().or(zod.null()).optional(),
	flow_version: zod.string().or(zod.null()).optional(),
	parameters: zod.object({}).optional(),
	empirical_policy: zod
		.object({
			max_retries: zod.number().optional(),
			retry_delay_seconds: zod.number().optional(),
			retries: zod.number().or(zod.null()).optional(),
			retry_delay: zod.number().or(zod.null()).optional(),
			pause_keys: zod.array(zod.string()).or(zod.null()).optional(),
			resuming: zod.boolean().or(zod.null()).optional(),
			retry_type: zod
				.enum(["in_process", "reschedule"])
				.or(zod.null())
				.optional(),
		})
		.optional(),
	tags: zod.array(zod.string()).optional(),
	infrastructure_pid: zod.string().or(zod.null()).optional(),
	job_variables: zod.object({}).or(zod.null()).optional(),
});

/**
 * Get a flow run by id.
 * @summary Read Flow Run
 */
export const readFlowRunFlowRunsIdGetParams = zod.object({
	id: zod.string().uuid(),
});

export const readFlowRunFlowRunsIdGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readFlowRunFlowRunsIdGetResponseEmpiricalPolicyMaxRetriesDefault = 0;
export const readFlowRunFlowRunsIdGetResponseEmpiricalPolicyRetryDelaySecondsDefault = 0;
export const readFlowRunFlowRunsIdGetResponseEmpiricalPolicyResumingDefault = false;
export const readFlowRunFlowRunsIdGetResponseRunCountDefault = 0;
export const readFlowRunFlowRunsIdGetResponseTotalRunTimeDefault = 0;
export const readFlowRunFlowRunsIdGetResponseEstimatedRunTimeDefault = 0;
export const readFlowRunFlowRunsIdGetResponseEstimatedStartTimeDeltaDefault = 0;
export const readFlowRunFlowRunsIdGetResponseAutoScheduledDefault = false;
export const readFlowRunFlowRunsIdGetResponseStateStateDetailsDeferredDefault = false;
export const readFlowRunFlowRunsIdGetResponseStateStateDetailsUntrackableResultDefault = false;
export const readFlowRunFlowRunsIdGetResponseStateStateDetailsPauseRescheduleDefault = false;

export const readFlowRunFlowRunsIdGetResponse = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().optional(),
	flow_id: zod.string().uuid(),
	state_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_version: zod.string().or(zod.null()).optional(),
	work_queue_id: zod.string().uuid().or(zod.null()).optional(),
	work_queue_name: zod.string().or(zod.null()).optional(),
	flow_version: zod.string().or(zod.null()).optional(),
	parameters: zod.object({}).optional(),
	idempotency_key: zod.string().or(zod.null()).optional(),
	context: zod.object({}).optional(),
	empirical_policy: zod
		.object({
			max_retries: zod.number().optional(),
			retry_delay_seconds: zod.number().optional(),
			retries: zod.number().or(zod.null()).optional(),
			retry_delay: zod.number().or(zod.null()).optional(),
			pause_keys: zod.array(zod.string()).or(zod.null()).optional(),
			resuming: zod.boolean().or(zod.null()).optional(),
			retry_type: zod
				.enum(["in_process", "reschedule"])
				.or(zod.null())
				.optional(),
		})
		.optional(),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.optional(),
	parent_task_run_id: zod.string().uuid().or(zod.null()).optional(),
	state_type: zod
		.enum([
			"SCHEDULED",
			"PENDING",
			"RUNNING",
			"COMPLETED",
			"FAILED",
			"CANCELLED",
			"CRASHED",
			"PAUSED",
			"CANCELLING",
		])
		.or(zod.null())
		.optional(),
	state_name: zod.string().or(zod.null()).optional(),
	run_count: zod.number().optional(),
	expected_start_time: zod.string().datetime().or(zod.null()).optional(),
	next_scheduled_start_time: zod.string().datetime().or(zod.null()).optional(),
	start_time: zod.string().datetime().or(zod.null()).optional(),
	end_time: zod.string().datetime().or(zod.null()).optional(),
	total_run_time: zod.number().optional(),
	estimated_run_time: zod.number().optional(),
	estimated_start_time_delta: zod.number().optional(),
	auto_scheduled: zod.boolean().optional(),
	infrastructure_document_id: zod.string().uuid().or(zod.null()).optional(),
	infrastructure_pid: zod.string().or(zod.null()).optional(),
	created_by: zod
		.object({
			id: zod.string().uuid().or(zod.null()).optional(),
			type: zod.string().or(zod.null()).optional(),
			display_value: zod.string().or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
	work_pool_id: zod.string().uuid().or(zod.null()).optional(),
	work_pool_name: zod.string().or(zod.null()).optional(),
	state: zod
		.object({
			id: zod.string().uuid(),
			type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			name: zod.string().or(zod.null()).optional(),
			timestamp: zod.string().datetime().optional(),
			message: zod.string().or(zod.null()).optional(),
			data: zod.any().or(zod.null()).optional(),
			state_details: zod
				.object({
					flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					task_run_id: zod.string().uuid().or(zod.null()).optional(),
					child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					scheduled_time: zod.string().datetime().or(zod.null()).optional(),
					cache_key: zod.string().or(zod.null()).optional(),
					cache_expiration: zod.string().datetime().or(zod.null()).optional(),
					deferred: zod.boolean().or(zod.null()).optional(),
					untrackable_result: zod.boolean().optional(),
					pause_timeout: zod.string().datetime().or(zod.null()).optional(),
					pause_reschedule: zod.boolean().optional(),
					pause_key: zod.string().or(zod.null()).optional(),
					run_input_keyset: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
					refresh_cache: zod.boolean().or(zod.null()).optional(),
					retriable: zod.boolean().or(zod.null()).optional(),
					transition_id: zod.string().uuid().or(zod.null()).optional(),
					task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
					traceparent: zod.string().or(zod.null()).optional(),
				})
				.optional(),
		})
		.or(zod.null())
		.optional(),
	job_variables: zod.object({}).or(zod.null()).optional(),
});

/**
 * Delete a flow run by id.
 * @summary Delete Flow Run
 */
export const deleteFlowRunFlowRunsIdDeleteParams = zod.object({
	id: zod.string().uuid(),
});

export const deleteFlowRunFlowRunsIdDeleteHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

/**
 * Query for flow runs.
 * @summary Count Flow Runs
 */
export const countFlowRunsFlowRunsCountPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const countFlowRunsFlowRunsCountPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const countFlowRunsFlowRunsCountPostBody = zod.object({
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	work_pool_queues: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					startswith_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
});

export const countFlowRunsFlowRunsCountPostResponse = zod.number();

/**
 * Query for average flow-run lateness in seconds.
 * @summary Average Flow Run Lateness
 */
export const averageFlowRunLatenessFlowRunsLatenessPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const averageFlowRunLatenessFlowRunsLatenessPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const averageFlowRunLatenessFlowRunsLatenessPostBody = zod.object({
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	work_pool_queues: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					startswith_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
});

export const averageFlowRunLatenessFlowRunsLatenessPostResponse = zod
	.number()
	.or(zod.null());

/**
 * Query for flow run history data across a given range and interval.
 * @summary Flow Run History
 */
export const flowRunHistoryFlowRunsHistoryPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const flowRunHistoryFlowRunsHistoryPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const flowRunHistoryFlowRunsHistoryPostBody = zod.object({
	history_start: zod.string().datetime(),
	history_end: zod.string().datetime(),
	history_interval: zod.number(),
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	work_queues: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					startswith_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
});

export const flowRunHistoryFlowRunsHistoryPostResponseItem = zod.object({
	interval_start: zod.string().datetime(),
	interval_end: zod.string().datetime(),
	states: zod.array(
		zod.object({
			state_type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			state_name: zod.string(),
			count_runs: zod.number(),
			sum_estimated_run_time: zod.number(),
			sum_estimated_lateness: zod.number(),
		}),
	),
});
export const flowRunHistoryFlowRunsHistoryPostResponse = zod.array(
	flowRunHistoryFlowRunsHistoryPostResponseItem,
);

/**
 * Resume a paused flow run.
 * @summary Resume Flow Run
 */
export const resumeFlowRunFlowRunsIdResumePostParams = zod.object({
	id: zod.string().uuid(),
});

export const resumeFlowRunFlowRunsIdResumePostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const resumeFlowRunFlowRunsIdResumePostBody = zod.object({
	run_input: zod.object({}).or(zod.null()).optional(),
});

export const resumeFlowRunFlowRunsIdResumePostResponseStateStateDetailsDeferredDefault = false;
export const resumeFlowRunFlowRunsIdResumePostResponseStateStateDetailsUntrackableResultDefault = false;
export const resumeFlowRunFlowRunsIdResumePostResponseStateStateDetailsPauseRescheduleDefault = false;
export const resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefault =
	"accept_details";
export const resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefaultOne =
	"wait_details";
export const resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefaultTwo =
	"reject_details";
export const resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefaultThree =
	"abort_details";

export const resumeFlowRunFlowRunsIdResumePostResponse = zod.object({
	state: zod
		.object({
			id: zod.string().uuid(),
			type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			name: zod.string().or(zod.null()).optional(),
			timestamp: zod.string().datetime().optional(),
			message: zod.string().or(zod.null()).optional(),
			data: zod.any().or(zod.null()).optional(),
			state_details: zod
				.object({
					flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					task_run_id: zod.string().uuid().or(zod.null()).optional(),
					child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					scheduled_time: zod.string().datetime().or(zod.null()).optional(),
					cache_key: zod.string().or(zod.null()).optional(),
					cache_expiration: zod.string().datetime().or(zod.null()).optional(),
					deferred: zod.boolean().or(zod.null()).optional(),
					untrackable_result: zod.boolean().optional(),
					pause_timeout: zod.string().datetime().or(zod.null()).optional(),
					pause_reschedule: zod.boolean().optional(),
					pause_key: zod.string().or(zod.null()).optional(),
					run_input_keyset: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
					refresh_cache: zod.boolean().or(zod.null()).optional(),
					retriable: zod.boolean().or(zod.null()).optional(),
					transition_id: zod.string().uuid().or(zod.null()).optional(),
					task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
					traceparent: zod.string().or(zod.null()).optional(),
				})
				.optional(),
		})
		.or(zod.null()),
	status: zod.enum(["ACCEPT", "REJECT", "ABORT", "WAIT"]),
	details: zod
		.object({
			type: zod
				.string()
				.default(resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefault),
		})
		.or(
			zod.object({
				type: zod
					.string()
					.default(
						resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefaultOne,
					),
				delay_seconds: zod.number(),
				reason: zod.string().or(zod.null()).optional(),
			}),
		)
		.or(
			zod.object({
				type: zod
					.string()
					.default(
						resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefaultTwo,
					),
				reason: zod.string().or(zod.null()).optional(),
			}),
		)
		.or(
			zod.object({
				type: zod
					.string()
					.default(
						resumeFlowRunFlowRunsIdResumePostResponseDetailsTypeDefaultThree,
					),
				reason: zod.string().or(zod.null()).optional(),
			}),
		),
});

/**
 * Query for flow runs.
 * @summary Read Flow Runs
 */
export const readFlowRunsFlowRunsFilterPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readFlowRunsFlowRunsFilterPostBodyOffsetDefault = 0;
export const readFlowRunsFlowRunsFilterPostBodyOffsetMin = 0;
export const readFlowRunsFlowRunsFilterPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const readFlowRunsFlowRunsFilterPostBody = zod.object({
	sort: zod
		.enum([
			"ID_DESC",
			"START_TIME_ASC",
			"START_TIME_DESC",
			"EXPECTED_START_TIME_ASC",
			"EXPECTED_START_TIME_DESC",
			"NAME_ASC",
			"NAME_DESC",
			"NEXT_SCHEDULED_START_TIME_ASC",
			"END_TIME_DESC",
		])
		.optional(),
	offset: zod
		.number()
		.min(readFlowRunsFlowRunsFilterPostBodyOffsetMin)
		.optional(),
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	work_pool_queues: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					startswith_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	limit: zod.number().optional(),
});

export const readFlowRunsFlowRunsFilterPostResponseEmpiricalPolicyMaxRetriesDefault = 0;
export const readFlowRunsFlowRunsFilterPostResponseEmpiricalPolicyRetryDelaySecondsDefault = 0;
export const readFlowRunsFlowRunsFilterPostResponseEmpiricalPolicyResumingDefault = false;
export const readFlowRunsFlowRunsFilterPostResponseRunCountDefault = 0;
export const readFlowRunsFlowRunsFilterPostResponseTotalRunTimeDefault = 0;
export const readFlowRunsFlowRunsFilterPostResponseEstimatedRunTimeDefault = 0;
export const readFlowRunsFlowRunsFilterPostResponseEstimatedStartTimeDeltaDefault = 0;
export const readFlowRunsFlowRunsFilterPostResponseAutoScheduledDefault = false;
export const readFlowRunsFlowRunsFilterPostResponseStateStateDetailsDeferredDefault = false;
export const readFlowRunsFlowRunsFilterPostResponseStateStateDetailsUntrackableResultDefault = false;
export const readFlowRunsFlowRunsFilterPostResponseStateStateDetailsPauseRescheduleDefault = false;

export const readFlowRunsFlowRunsFilterPostResponseItem = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().optional(),
	flow_id: zod.string().uuid(),
	state_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_version: zod.string().or(zod.null()).optional(),
	work_queue_id: zod.string().uuid().or(zod.null()).optional(),
	work_queue_name: zod.string().or(zod.null()).optional(),
	flow_version: zod.string().or(zod.null()).optional(),
	parameters: zod.object({}).optional(),
	idempotency_key: zod.string().or(zod.null()).optional(),
	context: zod.object({}).optional(),
	empirical_policy: zod
		.object({
			max_retries: zod.number().optional(),
			retry_delay_seconds: zod.number().optional(),
			retries: zod.number().or(zod.null()).optional(),
			retry_delay: zod.number().or(zod.null()).optional(),
			pause_keys: zod.array(zod.string()).or(zod.null()).optional(),
			resuming: zod.boolean().or(zod.null()).optional(),
			retry_type: zod
				.enum(["in_process", "reschedule"])
				.or(zod.null())
				.optional(),
		})
		.optional(),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.optional(),
	parent_task_run_id: zod.string().uuid().or(zod.null()).optional(),
	state_type: zod
		.enum([
			"SCHEDULED",
			"PENDING",
			"RUNNING",
			"COMPLETED",
			"FAILED",
			"CANCELLED",
			"CRASHED",
			"PAUSED",
			"CANCELLING",
		])
		.or(zod.null())
		.optional(),
	state_name: zod.string().or(zod.null()).optional(),
	run_count: zod.number().optional(),
	expected_start_time: zod.string().datetime().or(zod.null()).optional(),
	next_scheduled_start_time: zod.string().datetime().or(zod.null()).optional(),
	start_time: zod.string().datetime().or(zod.null()).optional(),
	end_time: zod.string().datetime().or(zod.null()).optional(),
	total_run_time: zod.number().optional(),
	estimated_run_time: zod.number().optional(),
	estimated_start_time_delta: zod.number().optional(),
	auto_scheduled: zod.boolean().optional(),
	infrastructure_document_id: zod.string().uuid().or(zod.null()).optional(),
	infrastructure_pid: zod.string().or(zod.null()).optional(),
	created_by: zod
		.object({
			id: zod.string().uuid().or(zod.null()).optional(),
			type: zod.string().or(zod.null()).optional(),
			display_value: zod.string().or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
	work_pool_id: zod.string().uuid().or(zod.null()).optional(),
	work_pool_name: zod.string().or(zod.null()).optional(),
	state: zod
		.object({
			id: zod.string().uuid(),
			type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			name: zod.string().or(zod.null()).optional(),
			timestamp: zod.string().datetime().optional(),
			message: zod.string().or(zod.null()).optional(),
			data: zod.any().or(zod.null()).optional(),
			state_details: zod
				.object({
					flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					task_run_id: zod.string().uuid().or(zod.null()).optional(),
					child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					scheduled_time: zod.string().datetime().or(zod.null()).optional(),
					cache_key: zod.string().or(zod.null()).optional(),
					cache_expiration: zod.string().datetime().or(zod.null()).optional(),
					deferred: zod.boolean().or(zod.null()).optional(),
					untrackable_result: zod.boolean().optional(),
					pause_timeout: zod.string().datetime().or(zod.null()).optional(),
					pause_reschedule: zod.boolean().optional(),
					pause_key: zod.string().or(zod.null()).optional(),
					run_input_keyset: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
					refresh_cache: zod.boolean().or(zod.null()).optional(),
					retriable: zod.boolean().or(zod.null()).optional(),
					transition_id: zod.string().uuid().or(zod.null()).optional(),
					task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
					traceparent: zod.string().or(zod.null()).optional(),
				})
				.optional(),
		})
		.or(zod.null())
		.optional(),
	job_variables: zod.object({}).or(zod.null()).optional(),
});
export const readFlowRunsFlowRunsFilterPostResponse = zod.array(
	readFlowRunsFlowRunsFilterPostResponseItem,
);

/**
 * Set a flow run state, invoking any orchestration rules.
 * @summary Set Flow Run State
 */
export const setFlowRunStateFlowRunsIdSetStatePostParams = zod.object({
	id: zod.string().uuid(),
});

export const setFlowRunStateFlowRunsIdSetStatePostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const setFlowRunStateFlowRunsIdSetStatePostBodyStateStateDetailsDeferredDefault = false;
export const setFlowRunStateFlowRunsIdSetStatePostBodyStateStateDetailsUntrackableResultDefault = false;
export const setFlowRunStateFlowRunsIdSetStatePostBodyStateStateDetailsPauseRescheduleDefault = false;
export const setFlowRunStateFlowRunsIdSetStatePostBodyForceDefault = false;

export const setFlowRunStateFlowRunsIdSetStatePostBody = zod.object({
	state: zod.object({
		type: zod.enum([
			"SCHEDULED",
			"PENDING",
			"RUNNING",
			"COMPLETED",
			"FAILED",
			"CANCELLED",
			"CRASHED",
			"PAUSED",
			"CANCELLING",
		]),
		name: zod.string().or(zod.null()).optional(),
		message: zod.string().or(zod.null()).optional(),
		data: zod.any().or(zod.null()).optional(),
		state_details: zod
			.object({
				flow_run_id: zod.string().uuid().or(zod.null()).optional(),
				task_run_id: zod.string().uuid().or(zod.null()).optional(),
				child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
				scheduled_time: zod.string().datetime().or(zod.null()).optional(),
				cache_key: zod.string().or(zod.null()).optional(),
				cache_expiration: zod.string().datetime().or(zod.null()).optional(),
				deferred: zod.boolean().or(zod.null()).optional(),
				untrackable_result: zod.boolean().optional(),
				pause_timeout: zod.string().datetime().or(zod.null()).optional(),
				pause_reschedule: zod.boolean().optional(),
				pause_key: zod.string().or(zod.null()).optional(),
				run_input_keyset: zod
					.record(zod.string(), zod.string())
					.or(zod.null())
					.optional(),
				refresh_cache: zod.boolean().or(zod.null()).optional(),
				retriable: zod.boolean().or(zod.null()).optional(),
				transition_id: zod.string().uuid().or(zod.null()).optional(),
				task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
				traceparent: zod.string().or(zod.null()).optional(),
			})
			.optional(),
	}),
	force: zod.boolean().optional(),
});

export const setFlowRunStateFlowRunsIdSetStatePostResponseStateStateDetailsDeferredDefault = false;
export const setFlowRunStateFlowRunsIdSetStatePostResponseStateStateDetailsUntrackableResultDefault = false;
export const setFlowRunStateFlowRunsIdSetStatePostResponseStateStateDetailsPauseRescheduleDefault = false;
export const setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefault =
	"accept_details";
export const setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefaultOne =
	"wait_details";
export const setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefaultTwo =
	"reject_details";
export const setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefaultThree =
	"abort_details";

export const setFlowRunStateFlowRunsIdSetStatePostResponse = zod.object({
	state: zod
		.object({
			id: zod.string().uuid(),
			type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			name: zod.string().or(zod.null()).optional(),
			timestamp: zod.string().datetime().optional(),
			message: zod.string().or(zod.null()).optional(),
			data: zod.any().or(zod.null()).optional(),
			state_details: zod
				.object({
					flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					task_run_id: zod.string().uuid().or(zod.null()).optional(),
					child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					scheduled_time: zod.string().datetime().or(zod.null()).optional(),
					cache_key: zod.string().or(zod.null()).optional(),
					cache_expiration: zod.string().datetime().or(zod.null()).optional(),
					deferred: zod.boolean().or(zod.null()).optional(),
					untrackable_result: zod.boolean().optional(),
					pause_timeout: zod.string().datetime().or(zod.null()).optional(),
					pause_reschedule: zod.boolean().optional(),
					pause_key: zod.string().or(zod.null()).optional(),
					run_input_keyset: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
					refresh_cache: zod.boolean().or(zod.null()).optional(),
					retriable: zod.boolean().or(zod.null()).optional(),
					transition_id: zod.string().uuid().or(zod.null()).optional(),
					task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
					traceparent: zod.string().or(zod.null()).optional(),
				})
				.optional(),
		})
		.or(zod.null()),
	status: zod.enum(["ACCEPT", "REJECT", "ABORT", "WAIT"]),
	details: zod
		.object({
			type: zod
				.string()
				.default(
					setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefault,
				),
		})
		.or(
			zod.object({
				type: zod
					.string()
					.default(
						setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefaultOne,
					),
				delay_seconds: zod.number(),
				reason: zod.string().or(zod.null()).optional(),
			}),
		)
		.or(
			zod.object({
				type: zod
					.string()
					.default(
						setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefaultTwo,
					),
				reason: zod.string().or(zod.null()).optional(),
			}),
		)
		.or(
			zod.object({
				type: zod
					.string()
					.default(
						setFlowRunStateFlowRunsIdSetStatePostResponseDetailsTypeDefaultThree,
					),
				reason: zod.string().or(zod.null()).optional(),
			}),
		),
});

/**
 * Create a key/value input for a flow run.
 * @summary Create Flow Run Input
 */
export const createFlowRunInputFlowRunsIdInputPostParams = zod.object({
	id: zod.string().uuid(),
});

export const createFlowRunInputFlowRunsIdInputPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const createFlowRunInputFlowRunsIdInputPostBody = zod.object({
	key: zod.string(),
	value: zod.instanceof(File),
	sender: zod.string().or(zod.null()).optional(),
});

/**
 * Filter flow run inputs by key prefix
 * @summary Filter Flow Run Input
 */
export const filterFlowRunInputFlowRunsIdInputFilterPostParams = zod.object({
	id: zod.string().uuid(),
});

export const filterFlowRunInputFlowRunsIdInputFilterPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const filterFlowRunInputFlowRunsIdInputFilterPostBodyLimitDefault = 1;
export const filterFlowRunInputFlowRunsIdInputFilterPostBodyExcludeKeysDefault =
	[];

export const filterFlowRunInputFlowRunsIdInputFilterPostBody = zod.object({
	prefix: zod.string(),
	limit: zod
		.number()
		.default(filterFlowRunInputFlowRunsIdInputFilterPostBodyLimitDefault),
	exclude_keys: zod
		.array(zod.string())
		.default(filterFlowRunInputFlowRunsIdInputFilterPostBodyExcludeKeysDefault),
});

export const filterFlowRunInputFlowRunsIdInputFilterPostResponseItem =
	zod.object({
		id: zod.string().uuid(),
		created: zod.string().datetime().or(zod.null()),
		updated: zod.string().datetime().or(zod.null()),
		flow_run_id: zod.string().uuid(),
		key: zod.string(),
		value: zod.string(),
		sender: zod.string().or(zod.null()).optional(),
	});
export const filterFlowRunInputFlowRunsIdInputFilterPostResponse = zod.array(
	filterFlowRunInputFlowRunsIdInputFilterPostResponseItem,
);

/**
 * Create a value from a flow run input
 * @summary Read Flow Run Input
 */
export const readFlowRunInputFlowRunsIdInputKeyGetParams = zod.object({
	id: zod.string().uuid(),
	key: zod.string(),
});

export const readFlowRunInputFlowRunsIdInputKeyGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readFlowRunInputFlowRunsIdInputKeyGetResponse = zod.any();

/**
 * Delete a flow run input
 * @summary Delete Flow Run Input
 */
export const deleteFlowRunInputFlowRunsIdInputKeyDeleteParams = zod.object({
	id: zod.string().uuid(),
	key: zod.string(),
});

export const deleteFlowRunInputFlowRunsIdInputKeyDeleteHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

/**
 * Pagination query for flow runs.
 * @summary Paginate Flow Runs
 */
export const paginateFlowRunsFlowRunsPaginatePostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const paginateFlowRunsFlowRunsPaginatePostBodyPageDefault = 1;
export const paginateFlowRunsFlowRunsPaginatePostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const paginateFlowRunsFlowRunsPaginatePostBody = zod.object({
	sort: zod
		.enum([
			"ID_DESC",
			"START_TIME_ASC",
			"START_TIME_DESC",
			"EXPECTED_START_TIME_ASC",
			"EXPECTED_START_TIME_DESC",
			"NAME_ASC",
			"NAME_DESC",
			"NEXT_SCHEDULED_START_TIME_ASC",
			"END_TIME_DESC",
		])
		.optional(),
	page: zod
		.number()
		.min(1)
		.default(paginateFlowRunsFlowRunsPaginatePostBodyPageDefault),
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	work_pool_queues: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					startswith_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	limit: zod.number().optional(),
});

export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemEmpiricalPolicyMaxRetriesDefault = 0;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemEmpiricalPolicyRetryDelaySecondsDefault = 0;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemEmpiricalPolicyResumingDefault = false;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemRunCountDefault = 0;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemTotalRunTimeDefault = 0;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemEstimatedRunTimeDefault = 0;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemEstimatedStartTimeDeltaDefault = 0;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemAutoScheduledDefault = false;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemStateStateDetailsDeferredDefault = false;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemStateStateDetailsUntrackableResultDefault = false;
export const paginateFlowRunsFlowRunsPaginatePostResponseResultsItemStateStateDetailsPauseRescheduleDefault = false;

export const paginateFlowRunsFlowRunsPaginatePostResponse = zod.object({
	results: zod.array(
		zod.object({
			id: zod.string().uuid(),
			created: zod.string().datetime().or(zod.null()),
			updated: zod.string().datetime().or(zod.null()),
			name: zod.string().optional(),
			flow_id: zod.string().uuid(),
			state_id: zod.string().uuid().or(zod.null()).optional(),
			deployment_id: zod.string().uuid().or(zod.null()).optional(),
			deployment_version: zod.string().or(zod.null()).optional(),
			work_queue_id: zod.string().uuid().or(zod.null()).optional(),
			work_queue_name: zod.string().or(zod.null()).optional(),
			flow_version: zod.string().or(zod.null()).optional(),
			parameters: zod.object({}).optional(),
			idempotency_key: zod.string().or(zod.null()).optional(),
			context: zod.object({}).optional(),
			empirical_policy: zod
				.object({
					max_retries: zod.number().optional(),
					retry_delay_seconds: zod.number().optional(),
					retries: zod.number().or(zod.null()).optional(),
					retry_delay: zod.number().or(zod.null()).optional(),
					pause_keys: zod.array(zod.string()).or(zod.null()).optional(),
					resuming: zod.boolean().or(zod.null()).optional(),
					retry_type: zod
						.enum(["in_process", "reschedule"])
						.or(zod.null())
						.optional(),
				})
				.optional(),
			tags: zod.array(zod.string()).optional(),
			labels: zod
				.record(
					zod.string(),
					zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
				)
				.optional(),
			parent_task_run_id: zod.string().uuid().or(zod.null()).optional(),
			state_type: zod
				.enum([
					"SCHEDULED",
					"PENDING",
					"RUNNING",
					"COMPLETED",
					"FAILED",
					"CANCELLED",
					"CRASHED",
					"PAUSED",
					"CANCELLING",
				])
				.or(zod.null())
				.optional(),
			state_name: zod.string().or(zod.null()).optional(),
			run_count: zod.number().optional(),
			expected_start_time: zod.string().datetime().or(zod.null()).optional(),
			next_scheduled_start_time: zod
				.string()
				.datetime()
				.or(zod.null())
				.optional(),
			start_time: zod.string().datetime().or(zod.null()).optional(),
			end_time: zod.string().datetime().or(zod.null()).optional(),
			total_run_time: zod.number().optional(),
			estimated_run_time: zod.number().optional(),
			estimated_start_time_delta: zod.number().optional(),
			auto_scheduled: zod.boolean().optional(),
			infrastructure_document_id: zod.string().uuid().or(zod.null()).optional(),
			infrastructure_pid: zod.string().or(zod.null()).optional(),
			created_by: zod
				.object({
					id: zod.string().uuid().or(zod.null()).optional(),
					type: zod.string().or(zod.null()).optional(),
					display_value: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_pool_id: zod.string().uuid().or(zod.null()).optional(),
			work_pool_name: zod.string().or(zod.null()).optional(),
			state: zod
				.object({
					id: zod.string().uuid(),
					type: zod.enum([
						"SCHEDULED",
						"PENDING",
						"RUNNING",
						"COMPLETED",
						"FAILED",
						"CANCELLED",
						"CRASHED",
						"PAUSED",
						"CANCELLING",
					]),
					name: zod.string().or(zod.null()).optional(),
					timestamp: zod.string().datetime().optional(),
					message: zod.string().or(zod.null()).optional(),
					data: zod.any().or(zod.null()).optional(),
					state_details: zod
						.object({
							flow_run_id: zod.string().uuid().or(zod.null()).optional(),
							task_run_id: zod.string().uuid().or(zod.null()).optional(),
							child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
							scheduled_time: zod.string().datetime().or(zod.null()).optional(),
							cache_key: zod.string().or(zod.null()).optional(),
							cache_expiration: zod
								.string()
								.datetime()
								.or(zod.null())
								.optional(),
							deferred: zod.boolean().or(zod.null()).optional(),
							untrackable_result: zod.boolean().optional(),
							pause_timeout: zod.string().datetime().or(zod.null()).optional(),
							pause_reschedule: zod.boolean().optional(),
							pause_key: zod.string().or(zod.null()).optional(),
							run_input_keyset: zod
								.record(zod.string(), zod.string())
								.or(zod.null())
								.optional(),
							refresh_cache: zod.boolean().or(zod.null()).optional(),
							retriable: zod.boolean().or(zod.null()).optional(),
							transition_id: zod.string().uuid().or(zod.null()).optional(),
							task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
							traceparent: zod.string().or(zod.null()).optional(),
						})
						.optional(),
				})
				.or(zod.null())
				.optional(),
			job_variables: zod.object({}).or(zod.null()).optional(),
		}),
	),
	count: zod.number(),
	limit: zod.number(),
	pages: zod.number(),
	page: zod.number(),
});

/**
 * Download all flow run logs as a CSV file, collecting all logs until there are no more logs to retrieve.
 * @summary Download Logs
 */
export const downloadLogsFlowRunsIdLogsDownloadGetParams = zod.object({
	id: zod.string().uuid(),
});

export const downloadLogsFlowRunsIdLogsDownloadGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const downloadLogsFlowRunsIdLogsDownloadGetResponse = zod.any();

/**
 * Update the labels of a flow run.
 * @summary Update Flow Run Labels
 */
export const updateFlowRunLabelsFlowRunsIdLabelsPatchParams = zod.object({
	id: zod.string().uuid(),
});

export const updateFlowRunLabelsFlowRunsIdLabelsPatchHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const updateFlowRunLabelsFlowRunsIdLabelsPatchBody = zod.object({});

/**
 * @summary Read Flow Run History
 */
export const readFlowRunHistoryUiFlowRunsHistoryPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readFlowRunHistoryUiFlowRunsHistoryPostBodyLimitDefault = 1000;
export const readFlowRunHistoryUiFlowRunsHistoryPostBodyLimitMax = 1000;
export const readFlowRunHistoryUiFlowRunsHistoryPostBodyOffsetDefault = 0;
export const readFlowRunHistoryUiFlowRunsHistoryPostBodyOffsetMin = 0;
export const readFlowRunHistoryUiFlowRunsHistoryPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const readFlowRunHistoryUiFlowRunsHistoryPostBody = zod.object({
	sort: zod
		.enum([
			"ID_DESC",
			"START_TIME_ASC",
			"START_TIME_DESC",
			"EXPECTED_START_TIME_ASC",
			"EXPECTED_START_TIME_DESC",
			"NAME_ASC",
			"NAME_DESC",
			"NEXT_SCHEDULED_START_TIME_ASC",
			"END_TIME_DESC",
		])
		.optional(),
	limit: zod
		.number()
		.max(readFlowRunHistoryUiFlowRunsHistoryPostBodyLimitMax)
		.default(readFlowRunHistoryUiFlowRunsHistoryPostBodyLimitDefault),
	offset: zod
		.number()
		.min(readFlowRunHistoryUiFlowRunsHistoryPostBodyOffsetMin)
		.optional(),
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
});

export const readFlowRunHistoryUiFlowRunsHistoryPostResponseItem = zod.object({
	id: zod.string().uuid(),
	state_type: zod.enum([
		"SCHEDULED",
		"PENDING",
		"RUNNING",
		"COMPLETED",
		"FAILED",
		"CANCELLED",
		"CRASHED",
		"PAUSED",
		"CANCELLING",
	]),
	timestamp: zod.string().datetime(),
	duration: zod.number(),
	lateness: zod.number(),
});
export const readFlowRunHistoryUiFlowRunsHistoryPostResponse = zod.array(
	readFlowRunHistoryUiFlowRunsHistoryPostResponseItem,
);

/**
 * Get task run counts by flow run id.
 * @summary Count Task Runs By Flow Run
 */
export const countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostHeader =
	zod.object({
		"x-prefect-api-version": zod.string().optional(),
	});

export const countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostBody = zod.object(
	{
		flow_run_ids: zod.array(zod.string().uuid()),
	},
);

export const countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostResponse =
	zod.record(zod.string(), zod.number());
