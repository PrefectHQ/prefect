/**
 * Generated by orval v7.6.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import {
  z as zod
} from 'zod';


/**
 * Gracefully creates a new flow from the provided schema. If a flow with the
same name already exists, the existing flow is returned.

For more information, see https://docs.prefect.io/v3/develop/write-flows.
 * @summary Create Flow
 */
export const createFlowFlowsPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const createFlowFlowsPostBodyNameRegExp = new RegExp('^[^/%&><]+$');


export const createFlowFlowsPostBody = zod.object({
  "name": zod.string().regex(createFlowFlowsPostBodyNameRegExp),
  "tags": zod.array(zod.string()).optional(),
  "labels": zod.record(zod.string(), zod.boolean().or(zod.number()).or(zod.number()).or(zod.string())).or(zod.null()).optional()
})

export const createFlowFlowsPostResponseNameRegExp = new RegExp('^[^/%&><]+$');


export const createFlowFlowsPostResponse = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(createFlowFlowsPostResponseNameRegExp),
  "tags": zod.array(zod.string()).optional(),
  "labels": zod.record(zod.string(), zod.boolean().or(zod.number()).or(zod.number()).or(zod.string())).or(zod.null()).optional()
})

/**
 * Updates a flow.
 * @summary Update Flow
 */
export const updateFlowFlowsIdPatchParams = zod.object({
  "id": zod.string().uuid()
})

export const updateFlowFlowsIdPatchHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const updateFlowFlowsIdPatchBody = zod.object({
  "tags": zod.array(zod.string()).optional()
})

/**
 * Get a flow by id.
 * @summary Read Flow
 */
export const readFlowFlowsIdGetParams = zod.object({
  "id": zod.string().uuid()
})

export const readFlowFlowsIdGetHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readFlowFlowsIdGetResponseNameRegExp = new RegExp('^[^/%&><]+$');


export const readFlowFlowsIdGetResponse = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(readFlowFlowsIdGetResponseNameRegExp),
  "tags": zod.array(zod.string()).optional(),
  "labels": zod.record(zod.string(), zod.boolean().or(zod.number()).or(zod.number()).or(zod.string())).or(zod.null()).optional()
})

/**
 * Delete a flow by id.
 * @summary Delete Flow
 */
export const deleteFlowFlowsIdDeleteParams = zod.object({
  "id": zod.string().uuid()
})

export const deleteFlowFlowsIdDeleteHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

/**
 * Count flows.
 * @summary Count Flows
 */
export const countFlowsFlowsCountPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const countFlowsFlowsCountPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const countFlowsFlowsCountPostBody = zod.object({
  "flows": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "deployment": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "flow_runs": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "deployment_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_queue_name": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "state": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "type": zod.object({
  "any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional(),
  "not_any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_version": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "end_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "expected_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "next_scheduled_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "parent_flow_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "parent_task_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "idempotency_key": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "task_runs": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "state": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "type": zod.object({
  "any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "expected_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "subflow_runs": zod.object({
  "exists_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "deployments": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_or_deployment_name": zod.object({
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "paused": zod.object({
  "eq_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_queue_name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "concurrency_limit": zod.object({
  "ge_": zod.number().or(zod.null()).optional(),
  "le_": zod.number().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "work_pools": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "type": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional()
})

export const countFlowsFlowsCountPostResponse = zod.number()

/**
 * Get a flow by name.
 * @summary Read Flow By Name
 */
export const readFlowByNameFlowsNameNameGetParams = zod.object({
  "name": zod.string()
})

export const readFlowByNameFlowsNameNameGetHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readFlowByNameFlowsNameNameGetResponseNameRegExp = new RegExp('^[^/%&><]+$');


export const readFlowByNameFlowsNameNameGetResponse = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(readFlowByNameFlowsNameNameGetResponseNameRegExp),
  "tags": zod.array(zod.string()).optional(),
  "labels": zod.record(zod.string(), zod.boolean().or(zod.number()).or(zod.number()).or(zod.string())).or(zod.null()).optional()
})

/**
 * Query for flows.
 * @summary Read Flows
 */
export const readFlowsFlowsFilterPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readFlowsFlowsFilterPostBodyOffsetDefault = 0;
export const readFlowsFlowsFilterPostBodyOffsetMin = 0;
export const readFlowsFlowsFilterPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const readFlowsFlowsFilterPostBody = zod.object({
  "offset": zod.number().min(readFlowsFlowsFilterPostBodyOffsetMin).optional(),
  "flows": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "deployment": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "flow_runs": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "deployment_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_queue_name": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "state": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "type": zod.object({
  "any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional(),
  "not_any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_version": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "end_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "expected_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "next_scheduled_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "parent_flow_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "parent_task_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "idempotency_key": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "task_runs": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "state": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "type": zod.object({
  "any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "expected_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "subflow_runs": zod.object({
  "exists_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "deployments": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_or_deployment_name": zod.object({
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "paused": zod.object({
  "eq_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_queue_name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "concurrency_limit": zod.object({
  "ge_": zod.number().or(zod.null()).optional(),
  "le_": zod.number().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "work_pools": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "type": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "sort": zod.enum(['CREATED_DESC', 'UPDATED_DESC', 'NAME_ASC', 'NAME_DESC']).optional(),
  "limit": zod.number().optional()
})

export const readFlowsFlowsFilterPostResponseNameRegExp = new RegExp('^[^/%&><]+$');


export const readFlowsFlowsFilterPostResponseItem = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(readFlowsFlowsFilterPostResponseNameRegExp),
  "tags": zod.array(zod.string()).optional(),
  "labels": zod.record(zod.string(), zod.boolean().or(zod.number()).or(zod.number()).or(zod.string())).or(zod.null()).optional()
})
export const readFlowsFlowsFilterPostResponse = zod.array(readFlowsFlowsFilterPostResponseItem)

/**
 * Pagination query for flows.
 * @summary Paginate Flows
 */
export const paginateFlowsFlowsPaginatePostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const paginateFlowsFlowsPaginatePostBodyPageDefault = 1;export const paginateFlowsFlowsPaginatePostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const paginateFlowsFlowsPaginatePostBody = zod.object({
  "page": zod.number().min(1).default(paginateFlowsFlowsPaginatePostBodyPageDefault),
  "flows": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "deployment": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_runs": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "deployment_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_queue_name": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "state": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "type": zod.object({
  "any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional(),
  "not_any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_version": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "end_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "expected_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "next_scheduled_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "parent_flow_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "parent_task_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "idempotency_key": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "not_any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "task_runs": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "state": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "type": zod.object({
  "any_": zod.array(zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING'])).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "expected_start_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "subflow_runs": zod.object({
  "exists_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_run_id": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "deployments": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "flow_or_deployment_name": zod.object({
  "like_": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "paused": zod.object({
  "eq_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "tags": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "all_": zod.array(zod.string()).or(zod.null()).optional(),
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_queue_name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "concurrency_limit": zod.object({
  "ge_": zod.number().or(zod.null()).optional(),
  "le_": zod.number().or(zod.null()).optional(),
  "is_null_": zod.boolean().or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_pools": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "type": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "sort": zod.enum(['CREATED_DESC', 'UPDATED_DESC', 'NAME_ASC', 'NAME_DESC']).optional(),
  "limit": zod.number().optional()
})

export const paginateFlowsFlowsPaginatePostResponseResultsItemNameRegExp = new RegExp('^[^/%&><]+$');


export const paginateFlowsFlowsPaginatePostResponse = zod.object({
  "results": zod.array(zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(paginateFlowsFlowsPaginatePostResponseResultsItemNameRegExp),
  "tags": zod.array(zod.string()).optional(),
  "labels": zod.record(zod.string(), zod.boolean().or(zod.number()).or(zod.number()).or(zod.string())).or(zod.null()).optional()
})),
  "count": zod.number(),
  "limit": zod.number(),
  "pages": zod.number(),
  "page": zod.number()
})

/**
 * Get deployment counts by flow id.
 * @summary Count Deployments By Flow
 */
export const countDeploymentsByFlowUiFlowsCountDeploymentsPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const countDeploymentsByFlowUiFlowsCountDeploymentsPostBody = zod.object({
  "flow_ids": zod.array(zod.string().uuid())
})

export const countDeploymentsByFlowUiFlowsCountDeploymentsPostResponse = zod.record(zod.string(), zod.number())

/**
 * Get the next flow run by flow id.
 * @summary Next Runs By Flow
 */
export const nextRunsByFlowUiFlowsNextRunsPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const nextRunsByFlowUiFlowsNextRunsPostBody = zod.object({
  "flow_ids": zod.array(zod.string().uuid())
})

export const nextRunsByFlowUiFlowsNextRunsPostResponse = zod.record(zod.string(), zod.object({
  "id": zod.string().uuid(),
  "flow_id": zod.string().uuid(),
  "name": zod.string(),
  "state_name": zod.string(),
  "state_type": zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING']),
  "next_scheduled_start_time": zod.string().datetime()
}).or(zod.null()))

