/**
 * Generated by orval v7.6.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { z as zod } from "zod";

/**
 * Gracefully creates a new flow from the provided schema. If a flow with the
same name already exists, the existing flow is returned.

For more information, see https://docs.prefect.io/v3/develop/write-flows.
 * @summary Create Flow
 */
export const createFlowFlowsPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const createFlowFlowsPostBodyNameRegExp = new RegExp("^[^/%&><]+$");

export const createFlowFlowsPostBody = zod.object({
	name: zod.string().regex(createFlowFlowsPostBodyNameRegExp),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.or(zod.null())
		.optional(),
});

export const createFlowFlowsPostResponseNameRegExp = new RegExp("^[^/%&><]+$");

export const createFlowFlowsPostResponse = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().regex(createFlowFlowsPostResponseNameRegExp),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.or(zod.null())
		.optional(),
});

/**
 * Updates a flow.
 * @summary Update Flow
 */
export const updateFlowFlowsIdPatchParams = zod.object({
	id: zod.string().uuid(),
});

export const updateFlowFlowsIdPatchHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const updateFlowFlowsIdPatchBody = zod.object({
	tags: zod.array(zod.string()).optional(),
});

/**
 * Get a flow by id.
 * @summary Read Flow
 */
export const readFlowFlowsIdGetParams = zod.object({
	id: zod.string().uuid(),
});

export const readFlowFlowsIdGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readFlowFlowsIdGetResponseNameRegExp = new RegExp("^[^/%&><]+$");

export const readFlowFlowsIdGetResponse = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().regex(readFlowFlowsIdGetResponseNameRegExp),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.or(zod.null())
		.optional(),
});

/**
 * Delete a flow by id.
 * @summary Delete Flow
 */
export const deleteFlowFlowsIdDeleteParams = zod.object({
	id: zod.string().uuid(),
});

export const deleteFlowFlowsIdDeleteHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

/**
 * Count flows.
 * @summary Count Flows
 */
export const countFlowsFlowsCountPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const countFlowsFlowsCountPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const countFlowsFlowsCountPostBody = zod.object({
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
});

export const countFlowsFlowsCountPostResponse = zod.number();

/**
 * Get a flow by name.
 * @summary Read Flow By Name
 */
export const readFlowByNameFlowsNameNameGetParams = zod.object({
	name: zod.string(),
});

export const readFlowByNameFlowsNameNameGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readFlowByNameFlowsNameNameGetResponseNameRegExp = new RegExp(
	"^[^/%&><]+$",
);

export const readFlowByNameFlowsNameNameGetResponse = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().regex(readFlowByNameFlowsNameNameGetResponseNameRegExp),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.or(zod.null())
		.optional(),
});

/**
 * Query for flows.
 * @summary Read Flows
 */
export const readFlowsFlowsFilterPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readFlowsFlowsFilterPostBodyOffsetDefault = 0;
export const readFlowsFlowsFilterPostBodyOffsetMin = 0;
export const readFlowsFlowsFilterPostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const readFlowsFlowsFilterPostBody = zod.object({
	offset: zod.number().min(readFlowsFlowsFilterPostBodyOffsetMin).optional(),
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	sort: zod
		.enum(["CREATED_DESC", "UPDATED_DESC", "NAME_ASC", "NAME_DESC"])
		.optional(),
	limit: zod.number().optional(),
});

export const readFlowsFlowsFilterPostResponseNameRegExp = new RegExp(
	"^[^/%&><]+$",
);

export const readFlowsFlowsFilterPostResponseItem = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().regex(readFlowsFlowsFilterPostResponseNameRegExp),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.or(zod.null())
		.optional(),
});
export const readFlowsFlowsFilterPostResponse = zod.array(
	readFlowsFlowsFilterPostResponseItem,
);

/**
 * Pagination query for flows.
 * @summary Paginate Flows
 */
export const paginateFlowsFlowsPaginatePostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const paginateFlowsFlowsPaginatePostBodyPageDefault = 1;
export const paginateFlowsFlowsPaginatePostBodyTaskRunsFlowRunIdIsNullDefault = false;

export const paginateFlowsFlowsPaginatePostBody = zod.object({
	page: zod
		.number()
		.min(1)
		.default(paginateFlowsFlowsPaginatePostBodyPageDefault),
	flows: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	flow_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			deployment_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
							not_any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
							not_any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			flow_version: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			end_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			next_scheduled_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			parent_task_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			idempotency_key: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					not_any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	task_runs: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			state: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					type: zod
						.object({
							any_: zod
								.array(
									zod.enum([
										"SCHEDULED",
										"PENDING",
										"RUNNING",
										"COMPLETED",
										"FAILED",
										"CANCELLED",
										"CRASHED",
										"PAUSED",
										"CANCELLING",
									]),
								)
								.or(zod.null())
								.optional(),
						})
						.or(zod.null())
						.optional(),
					name: zod
						.object({
							any_: zod.array(zod.string()).or(zod.null()).optional(),
						})
						.or(zod.null())
						.optional(),
				})
				.or(zod.null())
				.optional(),
			start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			expected_start_time: zod
				.object({
					before_: zod.string().datetime().or(zod.null()).optional(),
					after_: zod.string().datetime().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			subflow_runs: zod
				.object({
					exists_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_run_id: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	deployments: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			flow_or_deployment_name: zod
				.object({
					like_: zod.string().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			paused: zod
				.object({
					eq_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			tags: zod
				.object({
					operator: zod.enum(["and_", "or_"]).optional(),
					all_: zod.array(zod.string()).or(zod.null()).optional(),
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			work_queue_name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			concurrency_limit: zod
				.object({
					ge_: zod.number().or(zod.null()).optional(),
					le_: zod.number().or(zod.null()).optional(),
					is_null_: zod.boolean().or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	work_pools: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			type: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.or(zod.null())
		.optional(),
	sort: zod
		.enum(["CREATED_DESC", "UPDATED_DESC", "NAME_ASC", "NAME_DESC"])
		.optional(),
	limit: zod.number().optional(),
});

export const paginateFlowsFlowsPaginatePostResponseResultsItemNameRegExp =
	new RegExp("^[^/%&><]+$");

export const paginateFlowsFlowsPaginatePostResponse = zod.object({
	results: zod.array(
		zod.object({
			id: zod.string().uuid(),
			created: zod.string().datetime().or(zod.null()),
			updated: zod.string().datetime().or(zod.null()),
			name: zod
				.string()
				.regex(paginateFlowsFlowsPaginatePostResponseResultsItemNameRegExp),
			tags: zod.array(zod.string()).optional(),
			labels: zod
				.record(
					zod.string(),
					zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
				)
				.or(zod.null())
				.optional(),
		}),
	),
	count: zod.number(),
	limit: zod.number(),
	pages: zod.number(),
	page: zod.number(),
});

/**
 * Get deployment counts by flow id.
 * @summary Count Deployments By Flow
 */
export const countDeploymentsByFlowUiFlowsCountDeploymentsPostHeader =
	zod.object({
		"x-prefect-api-version": zod.string().optional(),
	});

export const countDeploymentsByFlowUiFlowsCountDeploymentsPostBody = zod.object(
	{
		flow_ids: zod.array(zod.string().uuid()),
	},
);

export const countDeploymentsByFlowUiFlowsCountDeploymentsPostResponse =
	zod.record(zod.string(), zod.number());

/**
 * Get the next flow run by flow id.
 * @summary Next Runs By Flow
 */
export const nextRunsByFlowUiFlowsNextRunsPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const nextRunsByFlowUiFlowsNextRunsPostBody = zod.object({
	flow_ids: zod.array(zod.string().uuid()),
});

export const nextRunsByFlowUiFlowsNextRunsPostResponse = zod.record(
	zod.string(),
	zod
		.object({
			id: zod.string().uuid(),
			flow_id: zod.string().uuid(),
			name: zod.string(),
			state_name: zod.string(),
			state_type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			next_scheduled_start_time: zod.string().datetime(),
		})
		.or(zod.null()),
);
