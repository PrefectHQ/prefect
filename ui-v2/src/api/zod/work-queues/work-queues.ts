/**
 * Generated by orval v7.6.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { z as zod } from "zod";

/**
 * Creates a new work queue.

If a work queue with the same name already exists, an error
will be raised.

For more information, see https://docs.prefect.io/v3/deploy/infrastructure-concepts/work-pools#work-queues.
 * @summary Create Work Queue
 */
export const createWorkQueueWorkQueuesPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const createWorkQueueWorkQueuesPostBodyNameRegExp = new RegExp(
	"^[^/%&><]+$",
);
export const createWorkQueueWorkQueuesPostBodyDescriptionDefault = "";
export const createWorkQueueWorkQueuesPostBodyIsPausedDefault = false;
export const createWorkQueueWorkQueuesPostBodyConcurrencyLimitMinOne = 0;

export const createWorkQueueWorkQueuesPostBody = zod.object({
	name: zod.string().regex(createWorkQueueWorkQueuesPostBodyNameRegExp),
	description: zod.string().or(zod.null()).optional(),
	is_paused: zod.boolean().optional(),
	concurrency_limit: zod
		.number()
		.min(createWorkQueueWorkQueuesPostBodyConcurrencyLimitMinOne)
		.or(zod.null())
		.optional(),
	priority: zod.number().or(zod.null()).optional(),
	filter: zod
		.object({
			tags: zod.array(zod.string()).or(zod.null()).optional(),
			deployment_ids: zod.array(zod.string().uuid()).or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
});

/**
 * Updates an existing work queue.
 * @summary Update Work Queue
 */
export const updateWorkQueueWorkQueuesIdPatchParams = zod.object({
	id: zod.string().uuid(),
});

export const updateWorkQueueWorkQueuesIdPatchHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const updateWorkQueueWorkQueuesIdPatchBodyIsPausedDefault = false;
export const updateWorkQueueWorkQueuesIdPatchBodyConcurrencyLimitMinOne = 0;

export const updateWorkQueueWorkQueuesIdPatchBody = zod.object({
	name: zod.string().or(zod.null()).optional(),
	description: zod.string().or(zod.null()).optional(),
	is_paused: zod.boolean().optional(),
	concurrency_limit: zod
		.number()
		.min(updateWorkQueueWorkQueuesIdPatchBodyConcurrencyLimitMinOne)
		.or(zod.null())
		.optional(),
	priority: zod.number().or(zod.null()).optional(),
	last_polled: zod.string().datetime().or(zod.null()).optional(),
	filter: zod
		.object({
			tags: zod.array(zod.string()).or(zod.null()).optional(),
			deployment_ids: zod.array(zod.string().uuid()).or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
});

/**
 * Get a work queue by id.
 * @summary Read Work Queue
 */
export const readWorkQueueWorkQueuesIdGetParams = zod.object({
	id: zod.string().uuid(),
});

export const readWorkQueueWorkQueuesIdGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readWorkQueueWorkQueuesIdGetResponseNameRegExp = new RegExp(
	"^[^/%&><]+$",
);
export const readWorkQueueWorkQueuesIdGetResponseDescriptionDefault = "";
export const readWorkQueueWorkQueuesIdGetResponseIsPausedDefault = false;
export const readWorkQueueWorkQueuesIdGetResponseConcurrencyLimitMinOne = 0;
export const readWorkQueueWorkQueuesIdGetResponsePriorityDefault = 1;

export const readWorkQueueWorkQueuesIdGetResponse = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().regex(readWorkQueueWorkQueuesIdGetResponseNameRegExp),
	description: zod.string().or(zod.null()).optional(),
	is_paused: zod.boolean().optional(),
	concurrency_limit: zod
		.number()
		.min(readWorkQueueWorkQueuesIdGetResponseConcurrencyLimitMinOne)
		.or(zod.null())
		.optional(),
	priority: zod
		.number()
		.default(readWorkQueueWorkQueuesIdGetResponsePriorityDefault),
	work_pool_id: zod.string().uuid().or(zod.null()).optional(),
	filter: zod
		.object({
			tags: zod.array(zod.string()).or(zod.null()).optional(),
			deployment_ids: zod.array(zod.string().uuid()).or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
	last_polled: zod.string().datetime().or(zod.null()).optional(),
	work_pool_name: zod.string().or(zod.null()).optional(),
	status: zod.enum(["READY", "NOT_READY", "PAUSED"]).or(zod.null()).optional(),
});

/**
 * Delete a work queue by id.
 * @summary Delete Work Queue
 */
export const deleteWorkQueueWorkQueuesIdDeleteParams = zod.object({
	id: zod.string().uuid(),
});

export const deleteWorkQueueWorkQueuesIdDeleteHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

/**
 * Get a work queue by id.
 * @summary Read Work Queue By Name
 */
export const readWorkQueueByNameWorkQueuesNameNameGetParams = zod.object({
	name: zod.string(),
});

export const readWorkQueueByNameWorkQueuesNameNameGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readWorkQueueByNameWorkQueuesNameNameGetResponseNameRegExp =
	new RegExp("^[^/%&><]+$");
export const readWorkQueueByNameWorkQueuesNameNameGetResponseDescriptionDefault =
	"";
export const readWorkQueueByNameWorkQueuesNameNameGetResponseIsPausedDefault = false;
export const readWorkQueueByNameWorkQueuesNameNameGetResponseConcurrencyLimitMinOne = 0;
export const readWorkQueueByNameWorkQueuesNameNameGetResponsePriorityDefault = 1;

export const readWorkQueueByNameWorkQueuesNameNameGetResponse = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod
		.string()
		.regex(readWorkQueueByNameWorkQueuesNameNameGetResponseNameRegExp),
	description: zod.string().or(zod.null()).optional(),
	is_paused: zod.boolean().optional(),
	concurrency_limit: zod
		.number()
		.min(readWorkQueueByNameWorkQueuesNameNameGetResponseConcurrencyLimitMinOne)
		.or(zod.null())
		.optional(),
	priority: zod
		.number()
		.default(readWorkQueueByNameWorkQueuesNameNameGetResponsePriorityDefault),
	work_pool_id: zod.string().uuid().or(zod.null()).optional(),
	filter: zod
		.object({
			tags: zod.array(zod.string()).or(zod.null()).optional(),
			deployment_ids: zod.array(zod.string().uuid()).or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
	last_polled: zod.string().datetime().or(zod.null()).optional(),
	work_pool_name: zod.string().or(zod.null()).optional(),
	status: zod.enum(["READY", "NOT_READY", "PAUSED"]).or(zod.null()).optional(),
});

/**
 * Get flow runs from the work queue.
 * @summary Read Work Queue Runs
 */
export const readWorkQueueRunsWorkQueuesIdGetRunsPostParams = zod.object({
	id: zod.string().uuid(),
});

export const readWorkQueueRunsWorkQueuesIdGetRunsPostHeaderXPrefectUiDefault = false;

export const readWorkQueueRunsWorkQueuesIdGetRunsPostHeader = zod.object({
	"x-prefect-ui": zod.boolean().or(zod.null()).optional(),
	"x-prefect-api-version": zod.string().optional(),
});

export const readWorkQueueRunsWorkQueuesIdGetRunsPostBody = zod.object({
	scheduled_before: zod.string().datetime().optional(),
	limit: zod.number().optional(),
});

export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseEmpiricalPolicyMaxRetriesDefault = 0;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseEmpiricalPolicyRetryDelaySecondsDefault = 0;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseEmpiricalPolicyResumingDefault = false;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseRunCountDefault = 0;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseTotalRunTimeDefault = 0;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseEstimatedRunTimeDefault = 0;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseEstimatedStartTimeDeltaDefault = 0;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseAutoScheduledDefault = false;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseStateStateDetailsDeferredDefault = false;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseStateStateDetailsUntrackableResultDefault = false;
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseStateStateDetailsPauseRescheduleDefault = false;

export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponseItem = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod.string().optional(),
	flow_id: zod.string().uuid(),
	state_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_id: zod.string().uuid().or(zod.null()).optional(),
	deployment_version: zod.string().or(zod.null()).optional(),
	work_queue_id: zod.string().uuid().or(zod.null()).optional(),
	work_queue_name: zod.string().or(zod.null()).optional(),
	flow_version: zod.string().or(zod.null()).optional(),
	parameters: zod.object({}).optional(),
	idempotency_key: zod.string().or(zod.null()).optional(),
	context: zod.object({}).optional(),
	empirical_policy: zod
		.object({
			max_retries: zod.number().optional(),
			retry_delay_seconds: zod.number().optional(),
			retries: zod.number().or(zod.null()).optional(),
			retry_delay: zod.number().or(zod.null()).optional(),
			pause_keys: zod.array(zod.string()).or(zod.null()).optional(),
			resuming: zod.boolean().or(zod.null()).optional(),
			retry_type: zod
				.enum(["in_process", "reschedule"])
				.or(zod.null())
				.optional(),
		})
		.optional(),
	tags: zod.array(zod.string()).optional(),
	labels: zod
		.record(
			zod.string(),
			zod.boolean().or(zod.number()).or(zod.number()).or(zod.string()),
		)
		.optional(),
	parent_task_run_id: zod.string().uuid().or(zod.null()).optional(),
	state_type: zod
		.enum([
			"SCHEDULED",
			"PENDING",
			"RUNNING",
			"COMPLETED",
			"FAILED",
			"CANCELLED",
			"CRASHED",
			"PAUSED",
			"CANCELLING",
		])
		.or(zod.null())
		.optional(),
	state_name: zod.string().or(zod.null()).optional(),
	run_count: zod.number().optional(),
	expected_start_time: zod.string().datetime().or(zod.null()).optional(),
	next_scheduled_start_time: zod.string().datetime().or(zod.null()).optional(),
	start_time: zod.string().datetime().or(zod.null()).optional(),
	end_time: zod.string().datetime().or(zod.null()).optional(),
	total_run_time: zod.number().optional(),
	estimated_run_time: zod.number().optional(),
	estimated_start_time_delta: zod.number().optional(),
	auto_scheduled: zod.boolean().optional(),
	infrastructure_document_id: zod.string().uuid().or(zod.null()).optional(),
	infrastructure_pid: zod.string().or(zod.null()).optional(),
	created_by: zod
		.object({
			id: zod.string().uuid().or(zod.null()).optional(),
			type: zod.string().or(zod.null()).optional(),
			display_value: zod.string().or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
	work_pool_id: zod.string().uuid().or(zod.null()).optional(),
	work_pool_name: zod.string().or(zod.null()).optional(),
	state: zod
		.object({
			id: zod.string().uuid(),
			type: zod.enum([
				"SCHEDULED",
				"PENDING",
				"RUNNING",
				"COMPLETED",
				"FAILED",
				"CANCELLED",
				"CRASHED",
				"PAUSED",
				"CANCELLING",
			]),
			name: zod.string().or(zod.null()).optional(),
			timestamp: zod.string().datetime().optional(),
			message: zod.string().or(zod.null()).optional(),
			data: zod.any().or(zod.null()).optional(),
			state_details: zod
				.object({
					flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					task_run_id: zod.string().uuid().or(zod.null()).optional(),
					child_flow_run_id: zod.string().uuid().or(zod.null()).optional(),
					scheduled_time: zod.string().datetime().or(zod.null()).optional(),
					cache_key: zod.string().or(zod.null()).optional(),
					cache_expiration: zod.string().datetime().or(zod.null()).optional(),
					deferred: zod.boolean().or(zod.null()).optional(),
					untrackable_result: zod.boolean().optional(),
					pause_timeout: zod.string().datetime().or(zod.null()).optional(),
					pause_reschedule: zod.boolean().optional(),
					pause_key: zod.string().or(zod.null()).optional(),
					run_input_keyset: zod
						.record(zod.string(), zod.string())
						.or(zod.null())
						.optional(),
					refresh_cache: zod.boolean().or(zod.null()).optional(),
					retriable: zod.boolean().or(zod.null()).optional(),
					transition_id: zod.string().uuid().or(zod.null()).optional(),
					task_parameters_id: zod.string().uuid().or(zod.null()).optional(),
					traceparent: zod.string().or(zod.null()).optional(),
				})
				.optional(),
		})
		.or(zod.null())
		.optional(),
	job_variables: zod.object({}).or(zod.null()).optional(),
});
export const readWorkQueueRunsWorkQueuesIdGetRunsPostResponse = zod.array(
	readWorkQueueRunsWorkQueuesIdGetRunsPostResponseItem,
);

/**
 * Query for work queues.
 * @summary Read Work Queues
 */
export const readWorkQueuesWorkQueuesFilterPostHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readWorkQueuesWorkQueuesFilterPostBodyOffsetDefault = 0;
export const readWorkQueuesWorkQueuesFilterPostBodyOffsetMin = 0;

export const readWorkQueuesWorkQueuesFilterPostBody = zod.object({
	offset: zod
		.number()
		.min(readWorkQueuesWorkQueuesFilterPostBodyOffsetMin)
		.optional(),
	work_queues: zod
		.object({
			operator: zod.enum(["and_", "or_"]).optional(),
			id: zod
				.object({
					any_: zod.array(zod.string().uuid()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
			name: zod
				.object({
					any_: zod.array(zod.string()).or(zod.null()).optional(),
					startswith_: zod.array(zod.string()).or(zod.null()).optional(),
				})
				.or(zod.null())
				.optional(),
		})
		.optional(),
	limit: zod.number().optional(),
});

export const readWorkQueuesWorkQueuesFilterPostResponseNameRegExp = new RegExp(
	"^[^/%&><]+$",
);
export const readWorkQueuesWorkQueuesFilterPostResponseDescriptionDefault = "";
export const readWorkQueuesWorkQueuesFilterPostResponseIsPausedDefault = false;
export const readWorkQueuesWorkQueuesFilterPostResponseConcurrencyLimitMinOne = 0;
export const readWorkQueuesWorkQueuesFilterPostResponsePriorityDefault = 1;

export const readWorkQueuesWorkQueuesFilterPostResponseItem = zod.object({
	id: zod.string().uuid(),
	created: zod.string().datetime().or(zod.null()),
	updated: zod.string().datetime().or(zod.null()),
	name: zod
		.string()
		.regex(readWorkQueuesWorkQueuesFilterPostResponseNameRegExp),
	description: zod.string().or(zod.null()).optional(),
	is_paused: zod.boolean().optional(),
	concurrency_limit: zod
		.number()
		.min(readWorkQueuesWorkQueuesFilterPostResponseConcurrencyLimitMinOne)
		.or(zod.null())
		.optional(),
	priority: zod
		.number()
		.default(readWorkQueuesWorkQueuesFilterPostResponsePriorityDefault),
	work_pool_id: zod.string().uuid().or(zod.null()).optional(),
	filter: zod
		.object({
			tags: zod.array(zod.string()).or(zod.null()).optional(),
			deployment_ids: zod.array(zod.string().uuid()).or(zod.null()).optional(),
		})
		.or(zod.null())
		.optional(),
	last_polled: zod.string().datetime().or(zod.null()).optional(),
	work_pool_name: zod.string().or(zod.null()).optional(),
	status: zod.enum(["READY", "NOT_READY", "PAUSED"]).or(zod.null()).optional(),
});
export const readWorkQueuesWorkQueuesFilterPostResponse = zod.array(
	readWorkQueuesWorkQueuesFilterPostResponseItem,
);

/**
 * Get the status of a work queue.
 * @summary Read Work Queue Status
 */
export const readWorkQueueStatusWorkQueuesIdStatusGetParams = zod.object({
	id: zod.string().uuid(),
});

export const readWorkQueueStatusWorkQueuesIdStatusGetHeader = zod.object({
	"x-prefect-api-version": zod.string().optional(),
});

export const readWorkQueueStatusWorkQueuesIdStatusGetResponseLateRunsCountDefault = 0;
export const readWorkQueueStatusWorkQueuesIdStatusGetResponseHealthCheckPolicyMaximumLateRunsDefault = 0;
export const readWorkQueueStatusWorkQueuesIdStatusGetResponseHealthCheckPolicyMaximumSecondsSinceLastPolledDefault = 60;

export const readWorkQueueStatusWorkQueuesIdStatusGetResponse = zod.object({
	healthy: zod.boolean(),
	late_runs_count: zod.number().optional(),
	last_polled: zod.string().datetime().or(zod.null()).optional(),
	health_check_policy: zod.object({
		maximum_late_runs: zod.number().or(zod.null()).optional(),
		maximum_seconds_since_last_polled: zod
			.number()
			.or(zod.null())
			.default(
				readWorkQueueStatusWorkQueuesIdStatusGetResponseHealthCheckPolicyMaximumSecondsSinceLastPolledDefault,
			),
	}),
});
