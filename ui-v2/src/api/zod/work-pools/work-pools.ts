/**
 * Generated by orval v7.6.0 🍺
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import {
  z as zod
} from 'zod';


/**
 * Creates a new work pool. If a work pool with the same
name already exists, an error will be raised.

For more information, see https://docs.prefect.io/v3/deploy/infrastructure-concepts/work-pools.
 * @summary Create Work Pool
 */
export const createWorkPoolWorkPoolsPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const createWorkPoolWorkPoolsPostBodyNameRegExp = new RegExp('^[^/%&><]+$');
export const createWorkPoolWorkPoolsPostBodyTypeDefault = "prefect-agent";export const createWorkPoolWorkPoolsPostBodyIsPausedDefault = false;export const createWorkPoolWorkPoolsPostBodyConcurrencyLimitMinOne = 0;


export const createWorkPoolWorkPoolsPostBody = zod.object({
  "name": zod.string().regex(createWorkPoolWorkPoolsPostBodyNameRegExp),
  "description": zod.string().or(zod.null()).optional(),
  "type": zod.string().default(createWorkPoolWorkPoolsPostBodyTypeDefault),
  "base_job_template": zod.object({

}).optional(),
  "is_paused": zod.boolean().optional(),
  "concurrency_limit": zod.number().min(createWorkPoolWorkPoolsPostBodyConcurrencyLimitMinOne).or(zod.null()).optional()
})

/**
 * Read a work pool by name
 * @summary Read Work Pool
 */
export const readWorkPoolWorkPoolsNameGetParams = zod.object({
  "name": zod.string()
})

export const readWorkPoolWorkPoolsNameGetHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readWorkPoolWorkPoolsNameGetResponseNameRegExp = new RegExp('^[^/%&><]+$');
export const readWorkPoolWorkPoolsNameGetResponseIsPausedDefault = false;export const readWorkPoolWorkPoolsNameGetResponseConcurrencyLimitMinOne = 0;


export const readWorkPoolWorkPoolsNameGetResponse = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(readWorkPoolWorkPoolsNameGetResponseNameRegExp),
  "description": zod.string().or(zod.null()).optional(),
  "type": zod.string(),
  "base_job_template": zod.object({

}).optional(),
  "is_paused": zod.boolean().optional(),
  "concurrency_limit": zod.number().min(readWorkPoolWorkPoolsNameGetResponseConcurrencyLimitMinOne).or(zod.null()).optional(),
  "status": zod.enum(['READY', 'NOT_READY', 'PAUSED']).or(zod.null()).optional(),
  "default_queue_id": zod.string().uuid().or(zod.null()).optional()
})

/**
 * Update a work pool
 * @summary Update Work Pool
 */
export const updateWorkPoolWorkPoolsNamePatchParams = zod.object({
  "name": zod.string()
})

export const updateWorkPoolWorkPoolsNamePatchHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const updateWorkPoolWorkPoolsNamePatchBodyConcurrencyLimitMinOne = 0;


export const updateWorkPoolWorkPoolsNamePatchBody = zod.object({
  "description": zod.string().or(zod.null()).optional(),
  "is_paused": zod.boolean().or(zod.null()).optional(),
  "base_job_template": zod.object({

}).or(zod.null()).optional(),
  "concurrency_limit": zod.number().min(updateWorkPoolWorkPoolsNamePatchBodyConcurrencyLimitMinOne).or(zod.null()).optional()
})

/**
 * Delete a work pool
 * @summary Delete Work Pool
 */
export const deleteWorkPoolWorkPoolsNameDeleteParams = zod.object({
  "name": zod.string()
})

export const deleteWorkPoolWorkPoolsNameDeleteHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

/**
 * Read multiple work pools
 * @summary Read Work Pools
 */
export const readWorkPoolsWorkPoolsFilterPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readWorkPoolsWorkPoolsFilterPostBodyOffsetDefault = 0;
export const readWorkPoolsWorkPoolsFilterPostBodyOffsetMin = 0;


export const readWorkPoolsWorkPoolsFilterPostBody = zod.object({
  "work_pools": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "type": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "offset": zod.number().min(readWorkPoolsWorkPoolsFilterPostBodyOffsetMin).optional(),
  "limit": zod.number().optional()
})

export const readWorkPoolsWorkPoolsFilterPostResponseNameRegExp = new RegExp('^[^/%&><]+$');
export const readWorkPoolsWorkPoolsFilterPostResponseIsPausedDefault = false;export const readWorkPoolsWorkPoolsFilterPostResponseConcurrencyLimitMinOne = 0;


export const readWorkPoolsWorkPoolsFilterPostResponseItem = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(readWorkPoolsWorkPoolsFilterPostResponseNameRegExp),
  "description": zod.string().or(zod.null()).optional(),
  "type": zod.string(),
  "base_job_template": zod.object({

}).optional(),
  "is_paused": zod.boolean().optional(),
  "concurrency_limit": zod.number().min(readWorkPoolsWorkPoolsFilterPostResponseConcurrencyLimitMinOne).or(zod.null()).optional(),
  "status": zod.enum(['READY', 'NOT_READY', 'PAUSED']).or(zod.null()).optional(),
  "default_queue_id": zod.string().uuid().or(zod.null()).optional()
})
export const readWorkPoolsWorkPoolsFilterPostResponse = zod.array(readWorkPoolsWorkPoolsFilterPostResponseItem)

/**
 * Count work pools
 * @summary Count Work Pools
 */
export const countWorkPoolsWorkPoolsCountPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const countWorkPoolsWorkPoolsCountPostBody = zod.object({
  "work_pools": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "type": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional()
})

export const countWorkPoolsWorkPoolsCountPostResponse = zod.number()

/**
 * Load scheduled runs for a worker
 * @summary Get Scheduled Flow Runs
 */
export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostParams = zod.object({
  "name": zod.string()
})

export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostBody = zod.object({
  "work_queue_names": zod.array(zod.string()).optional(),
  "scheduled_before": zod.string().datetime().optional(),
  "scheduled_after": zod.string().datetime().optional(),
  "limit": zod.number().optional()
})

export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunEmpiricalPolicyMaxRetriesDefault = 0;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunEmpiricalPolicyRetryDelaySecondsDefault = 0;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunEmpiricalPolicyResumingDefault = false;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunRunCountDefault = 0;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunTotalRunTimeDefault = 0;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunEstimatedRunTimeDefault = 0;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunEstimatedStartTimeDeltaDefault = 0;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunAutoScheduledDefault = false;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunStateStateDetailsDeferredDefault = false;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunStateStateDetailsUntrackableResultDefault = false;export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseFlowRunStateStateDetailsPauseRescheduleDefault = false;

export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseItem = zod.object({
  "work_pool_id": zod.string().uuid(),
  "work_queue_id": zod.string().uuid(),
  "flow_run": zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().optional(),
  "flow_id": zod.string().uuid(),
  "state_id": zod.string().uuid().or(zod.null()).optional(),
  "deployment_id": zod.string().uuid().or(zod.null()).optional(),
  "deployment_version": zod.string().or(zod.null()).optional(),
  "work_queue_name": zod.string().or(zod.null()).optional(),
  "flow_version": zod.string().or(zod.null()).optional(),
  "parameters": zod.object({

}).optional(),
  "idempotency_key": zod.string().or(zod.null()).optional(),
  "context": zod.object({

}).optional(),
  "empirical_policy": zod.object({
  "max_retries": zod.number().optional(),
  "retry_delay_seconds": zod.number().optional(),
  "retries": zod.number().or(zod.null()).optional(),
  "retry_delay": zod.number().or(zod.null()).optional(),
  "pause_keys": zod.array(zod.string()).or(zod.null()).optional(),
  "resuming": zod.boolean().or(zod.null()).optional(),
  "retry_type": zod.enum(['in_process', 'reschedule']).or(zod.null()).optional()
}).optional(),
  "tags": zod.array(zod.string()).optional(),
  "labels": zod.record(zod.string(), zod.boolean().or(zod.number()).or(zod.number()).or(zod.string())).or(zod.null()).optional(),
  "parent_task_run_id": zod.string().uuid().or(zod.null()).optional(),
  "state_type": zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING']).or(zod.null()).optional(),
  "state_name": zod.string().or(zod.null()).optional(),
  "run_count": zod.number().optional(),
  "expected_start_time": zod.string().datetime().or(zod.null()).optional(),
  "next_scheduled_start_time": zod.string().datetime().or(zod.null()).optional(),
  "start_time": zod.string().datetime().or(zod.null()).optional(),
  "end_time": zod.string().datetime().or(zod.null()).optional(),
  "total_run_time": zod.number().optional(),
  "estimated_run_time": zod.number().optional(),
  "estimated_start_time_delta": zod.number().optional(),
  "auto_scheduled": zod.boolean().optional(),
  "infrastructure_document_id": zod.string().uuid().or(zod.null()).optional(),
  "infrastructure_pid": zod.string().or(zod.null()).optional(),
  "created_by": zod.object({
  "id": zod.string().uuid().or(zod.null()).optional(),
  "type": zod.string().or(zod.null()).optional(),
  "display_value": zod.string().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "work_queue_id": zod.string().uuid().or(zod.null()).optional(),
  "state": zod.object({
  "id": zod.string().uuid(),
  "type": zod.enum(['SCHEDULED', 'PENDING', 'RUNNING', 'COMPLETED', 'FAILED', 'CANCELLED', 'CRASHED', 'PAUSED', 'CANCELLING']),
  "name": zod.string().or(zod.null()).optional(),
  "timestamp": zod.string().datetime().optional(),
  "message": zod.string().or(zod.null()).optional(),
  "data": zod.any().or(zod.null()).optional(),
  "state_details": zod.object({
  "flow_run_id": zod.string().uuid().or(zod.null()).optional(),
  "task_run_id": zod.string().uuid().or(zod.null()).optional(),
  "child_flow_run_id": zod.string().uuid().or(zod.null()).optional(),
  "scheduled_time": zod.string().datetime().or(zod.null()).optional(),
  "cache_key": zod.string().or(zod.null()).optional(),
  "cache_expiration": zod.string().datetime().or(zod.null()).optional(),
  "deferred": zod.boolean().or(zod.null()).optional(),
  "untrackable_result": zod.boolean().optional(),
  "pause_timeout": zod.string().datetime().or(zod.null()).optional(),
  "pause_reschedule": zod.boolean().optional(),
  "pause_key": zod.string().or(zod.null()).optional(),
  "run_input_keyset": zod.record(zod.string(), zod.string()).or(zod.null()).optional(),
  "refresh_cache": zod.boolean().or(zod.null()).optional(),
  "retriable": zod.boolean().or(zod.null()).optional(),
  "transition_id": zod.string().uuid().or(zod.null()).optional(),
  "task_parameters_id": zod.string().uuid().or(zod.null()).optional(),
  "traceparent": zod.string().or(zod.null()).optional()
}).optional()
}).or(zod.null()).optional(),
  "job_variables": zod.object({

}).or(zod.null()).optional()
})
})
export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponse = zod.array(getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponseItem)

/**
 * Creates a new work pool queue. If a work pool queue with the same
name already exists, an error will be raised.

For more information, see https://docs.prefect.io/v3/deploy/infrastructure-concepts/work-pools#work-queues.
 * @summary Create Work Queue
 */
export const createWorkQueueWorkPoolsWorkPoolNameQueuesPostParams = zod.object({
  "work_pool_name": zod.string()
})

export const createWorkQueueWorkPoolsWorkPoolNameQueuesPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const createWorkQueueWorkPoolsWorkPoolNameQueuesPostBodyNameRegExp = new RegExp('^[^/%&><]+$');
export const createWorkQueueWorkPoolsWorkPoolNameQueuesPostBodyDescriptionDefault = "";export const createWorkQueueWorkPoolsWorkPoolNameQueuesPostBodyIsPausedDefault = false;export const createWorkQueueWorkPoolsWorkPoolNameQueuesPostBodyConcurrencyLimitMinOne = 0;


export const createWorkQueueWorkPoolsWorkPoolNameQueuesPostBody = zod.object({
  "name": zod.string().regex(createWorkQueueWorkPoolsWorkPoolNameQueuesPostBodyNameRegExp),
  "description": zod.string().or(zod.null()).optional(),
  "is_paused": zod.boolean().optional(),
  "concurrency_limit": zod.number().min(createWorkQueueWorkPoolsWorkPoolNameQueuesPostBodyConcurrencyLimitMinOne).or(zod.null()).optional(),
  "priority": zod.number().or(zod.null()).optional(),
  "filter": zod.object({
  "tags": zod.array(zod.string()).or(zod.null()).optional(),
  "deployment_ids": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional()
})

/**
 * Read a work pool queue
 * @summary Read Work Queue
 */
export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetParams = zod.object({
  "work_pool_name": zod.string(),
  "name": zod.string()
})

export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponseNameRegExp = new RegExp('^[^/%&><]+$');
export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponseDescriptionDefault = "";export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponseIsPausedDefault = false;export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponseConcurrencyLimitMinOne = 0;
export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponsePriorityDefault = 1;

export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponse = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponseNameRegExp),
  "description": zod.string().or(zod.null()).optional(),
  "is_paused": zod.boolean().optional(),
  "concurrency_limit": zod.number().min(readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponseConcurrencyLimitMinOne).or(zod.null()).optional(),
  "priority": zod.number().default(readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponsePriorityDefault),
  "work_pool_id": zod.string().uuid().or(zod.null()).optional(),
  "filter": zod.object({
  "tags": zod.array(zod.string()).or(zod.null()).optional(),
  "deployment_ids": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "last_polled": zod.string().datetime().or(zod.null()).optional(),
  "work_pool_name": zod.string().or(zod.null()).optional(),
  "status": zod.enum(['READY', 'NOT_READY', 'PAUSED']).or(zod.null()).optional()
})

/**
 * Update a work pool queue
 * @summary Update Work Queue
 */
export const updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchParams = zod.object({
  "work_pool_name": zod.string(),
  "name": zod.string()
})

export const updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchBodyIsPausedDefault = false;export const updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchBodyConcurrencyLimitMinOne = 0;


export const updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchBody = zod.object({
  "name": zod.string().or(zod.null()).optional(),
  "description": zod.string().or(zod.null()).optional(),
  "is_paused": zod.boolean().optional(),
  "concurrency_limit": zod.number().min(updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchBodyConcurrencyLimitMinOne).or(zod.null()).optional(),
  "priority": zod.number().or(zod.null()).optional(),
  "last_polled": zod.string().datetime().or(zod.null()).optional(),
  "filter": zod.object({
  "tags": zod.array(zod.string()).or(zod.null()).optional(),
  "deployment_ids": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional()
})

/**
 * Delete a work pool queue
 * @summary Delete Work Queue
 */
export const deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteParams = zod.object({
  "work_pool_name": zod.string(),
  "name": zod.string()
})

export const deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

/**
 * Read all work pool queues
 * @summary Read Work Queues
 */
export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostParams = zod.object({
  "work_pool_name": zod.string()
})

export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostBodyOffsetDefault = 0;
export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostBodyOffsetMin = 0;


export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostBody = zod.object({
  "work_queues": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "id": zod.object({
  "any_": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "name": zod.object({
  "any_": zod.array(zod.string()).or(zod.null()).optional(),
  "startswith_": zod.array(zod.string()).or(zod.null()).optional()
}).or(zod.null()).optional()
}).optional(),
  "offset": zod.number().min(readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostBodyOffsetMin).optional(),
  "limit": zod.number().optional()
})

export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseNameRegExp = new RegExp('^[^/%&><]+$');
export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseDescriptionDefault = "";export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseIsPausedDefault = false;export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseConcurrencyLimitMinOne = 0;
export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponsePriorityDefault = 1;

export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseItem = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string().regex(readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseNameRegExp),
  "description": zod.string().or(zod.null()).optional(),
  "is_paused": zod.boolean().optional(),
  "concurrency_limit": zod.number().min(readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseConcurrencyLimitMinOne).or(zod.null()).optional(),
  "priority": zod.number().default(readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponsePriorityDefault),
  "work_pool_id": zod.string().uuid().or(zod.null()).optional(),
  "filter": zod.object({
  "tags": zod.array(zod.string()).or(zod.null()).optional(),
  "deployment_ids": zod.array(zod.string().uuid()).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "last_polled": zod.string().datetime().or(zod.null()).optional(),
  "work_pool_name": zod.string().or(zod.null()).optional(),
  "status": zod.enum(['READY', 'NOT_READY', 'PAUSED']).or(zod.null()).optional()
})
export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponse = zod.array(readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponseItem)

/**
 * @summary Worker Heartbeat
 */
export const workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostParams = zod.object({
  "work_pool_name": zod.string()
})

export const workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostBody = zod.object({
  "name": zod.string(),
  "heartbeat_interval_seconds": zod.number().or(zod.null()).optional()
})

/**
 * Read all worker processes
 * @summary Read Workers
 */
export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPostParams = zod.object({
  "work_pool_name": zod.string()
})

export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPostHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPostBodyOffsetDefault = 0;
export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPostBodyOffsetMin = 0;


export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPostBody = zod.object({
  "workers": zod.object({
  "operator": zod.enum(['and_', 'or_']).optional(),
  "last_heartbeat_time": zod.object({
  "before_": zod.string().datetime().or(zod.null()).optional(),
  "after_": zod.string().datetime().or(zod.null()).optional()
}).or(zod.null()).optional(),
  "status": zod.object({
  "any_": zod.array(zod.enum(['ONLINE', 'OFFLINE'])).or(zod.null()).optional(),
  "not_any_": zod.array(zod.enum(['ONLINE', 'OFFLINE'])).or(zod.null()).optional()
}).or(zod.null()).optional()
}).or(zod.null()).optional(),
  "offset": zod.number().min(readWorkersWorkPoolsWorkPoolNameWorkersFilterPostBodyOffsetMin).optional(),
  "limit": zod.number().optional()
})

export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPostResponseItem = zod.object({
  "id": zod.string().uuid(),
  "created": zod.string().datetime().or(zod.null()),
  "updated": zod.string().datetime().or(zod.null()),
  "name": zod.string(),
  "work_pool_id": zod.string().uuid(),
  "last_heartbeat_time": zod.string().datetime().optional(),
  "heartbeat_interval_seconds": zod.number().or(zod.null()).optional(),
  "status": zod.enum(['ONLINE', 'OFFLINE']).optional()
})
export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPostResponse = zod.array(readWorkersWorkPoolsWorkPoolNameWorkersFilterPostResponseItem)

/**
 * Delete a work pool's worker
 * @summary Delete Worker
 */
export const deleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteParams = zod.object({
  "work_pool_name": zod.string(),
  "name": zod.string()
})

export const deleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteHeader = zod.object({
  "x-prefect-api-version": zod.string().optional()
})

