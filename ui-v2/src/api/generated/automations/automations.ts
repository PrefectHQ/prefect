/**
 * Generated by orval v7.5.0 ðŸº
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	Automation,
	AutomationCreate,
	AutomationPartialUpdate,
	AutomationUpdate,
	BodyReadAutomationsAutomationsFilterPost,
	HTTPValidationError,
} from "../../models";

/**
 * @summary Create Automation
 */
export type createAutomationAutomationsPostResponse = {
	data: Automation | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateAutomationAutomationsPostUrl = () => {
	return `http://prefect.grose.click/api/automations/`;
};

export const createAutomationAutomationsPost = async (
	automationCreate: AutomationCreate,
	options?: RequestInit,
): Promise<createAutomationAutomationsPostResponse> => {
	const res = await fetch(getCreateAutomationAutomationsPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(automationCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createAutomationAutomationsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createAutomationAutomationsPostResponse;
};

export const getCreateAutomationAutomationsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createAutomationAutomationsPost>>,
		TError,
		{ data: AutomationCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createAutomationAutomationsPost>>,
	TError,
	{ data: AutomationCreate },
	TContext
> => {
	const mutationKey = ["createAutomationAutomationsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createAutomationAutomationsPost>>,
		{ data: AutomationCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createAutomationAutomationsPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateAutomationAutomationsPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createAutomationAutomationsPost>>
>;
export type CreateAutomationAutomationsPostMutationBody = AutomationCreate;
export type CreateAutomationAutomationsPostMutationError = HTTPValidationError;

/**
 * @summary Create Automation
 */
export const useCreateAutomationAutomationsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createAutomationAutomationsPost>>,
		TError,
		{ data: AutomationCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createAutomationAutomationsPost>>,
	TError,
	{ data: AutomationCreate },
	TContext
> => {
	const mutationOptions =
		getCreateAutomationAutomationsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Update Automation
 */
export type updateAutomationAutomationsIdPutResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateAutomationAutomationsIdPutUrl = (id: string) => {
	return `http://prefect.grose.click/api/automations/${id}`;
};

export const updateAutomationAutomationsIdPut = async (
	id: string,
	automationUpdate: AutomationUpdate,
	options?: RequestInit,
): Promise<updateAutomationAutomationsIdPutResponse> => {
	const res = await fetch(getUpdateAutomationAutomationsIdPutUrl(id), {
		...options,
		method: "PUT",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(automationUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateAutomationAutomationsIdPutResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateAutomationAutomationsIdPutResponse;
};

export const getUpdateAutomationAutomationsIdPutMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateAutomationAutomationsIdPut>>,
		TError,
		{ id: string; data: AutomationUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateAutomationAutomationsIdPut>>,
	TError,
	{ id: string; data: AutomationUpdate },
	TContext
> => {
	const mutationKey = ["updateAutomationAutomationsIdPut"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateAutomationAutomationsIdPut>>,
		{ id: string; data: AutomationUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateAutomationAutomationsIdPut(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateAutomationAutomationsIdPutMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateAutomationAutomationsIdPut>>
>;
export type UpdateAutomationAutomationsIdPutMutationBody = AutomationUpdate;
export type UpdateAutomationAutomationsIdPutMutationError = HTTPValidationError;

/**
 * @summary Update Automation
 */
export const useUpdateAutomationAutomationsIdPut = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateAutomationAutomationsIdPut>>,
		TError,
		{ id: string; data: AutomationUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateAutomationAutomationsIdPut>>,
	TError,
	{ id: string; data: AutomationUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateAutomationAutomationsIdPutMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Patch Automation
 */
export type patchAutomationAutomationsIdPatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getPatchAutomationAutomationsIdPatchUrl = (id: string) => {
	return `http://prefect.grose.click/api/automations/${id}`;
};

export const patchAutomationAutomationsIdPatch = async (
	id: string,
	automationPartialUpdate: AutomationPartialUpdate,
	options?: RequestInit,
): Promise<patchAutomationAutomationsIdPatchResponse> => {
	const res = await fetch(getPatchAutomationAutomationsIdPatchUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(automationPartialUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: patchAutomationAutomationsIdPatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as patchAutomationAutomationsIdPatchResponse;
};

export const getPatchAutomationAutomationsIdPatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof patchAutomationAutomationsIdPatch>>,
		TError,
		{ id: string; data: AutomationPartialUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof patchAutomationAutomationsIdPatch>>,
	TError,
	{ id: string; data: AutomationPartialUpdate },
	TContext
> => {
	const mutationKey = ["patchAutomationAutomationsIdPatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof patchAutomationAutomationsIdPatch>>,
		{ id: string; data: AutomationPartialUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return patchAutomationAutomationsIdPatch(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PatchAutomationAutomationsIdPatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof patchAutomationAutomationsIdPatch>>
>;
export type PatchAutomationAutomationsIdPatchMutationBody =
	AutomationPartialUpdate;
export type PatchAutomationAutomationsIdPatchMutationError =
	HTTPValidationError;

/**
 * @summary Patch Automation
 */
export const usePatchAutomationAutomationsIdPatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof patchAutomationAutomationsIdPatch>>,
		TError,
		{ id: string; data: AutomationPartialUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof patchAutomationAutomationsIdPatch>>,
	TError,
	{ id: string; data: AutomationPartialUpdate },
	TContext
> => {
	const mutationOptions =
		getPatchAutomationAutomationsIdPatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Delete Automation
 */
export type deleteAutomationAutomationsIdDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteAutomationAutomationsIdDeleteUrl = (id: string) => {
	return `http://prefect.grose.click/api/automations/${id}`;
};

export const deleteAutomationAutomationsIdDelete = async (
	id: string,
	options?: RequestInit,
): Promise<deleteAutomationAutomationsIdDeleteResponse> => {
	const res = await fetch(getDeleteAutomationAutomationsIdDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteAutomationAutomationsIdDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteAutomationAutomationsIdDeleteResponse;
};

export const getDeleteAutomationAutomationsIdDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteAutomationAutomationsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteAutomationAutomationsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["deleteAutomationAutomationsIdDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteAutomationAutomationsIdDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return deleteAutomationAutomationsIdDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteAutomationAutomationsIdDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteAutomationAutomationsIdDelete>>
>;

export type DeleteAutomationAutomationsIdDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Automation
 */
export const useDeleteAutomationAutomationsIdDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteAutomationAutomationsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteAutomationAutomationsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getDeleteAutomationAutomationsIdDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Read Automation
 */
export type readAutomationAutomationsIdGetResponse = {
	data: Automation | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadAutomationAutomationsIdGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/automations/${id}`;
};

export const readAutomationAutomationsIdGet = async (
	id: string,
	options?: RequestInit,
): Promise<readAutomationAutomationsIdGetResponse> => {
	const res = await fetch(getReadAutomationAutomationsIdGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readAutomationAutomationsIdGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readAutomationAutomationsIdGetResponse;
};

export const getReadAutomationAutomationsIdGetQueryKey = (id: string) => {
	return [`http://prefect.grose.click/api/automations/${id}`] as const;
};

export const getReadAutomationAutomationsIdGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadAutomationAutomationsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>
	> = ({ signal }) =>
		readAutomationAutomationsIdGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadAutomationAutomationsIdGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>
>;
export type ReadAutomationAutomationsIdGetQueryError = HTTPValidationError;

export function useReadAutomationAutomationsIdGet<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationAutomationsIdGet<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationAutomationsIdGet<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Automation
 */

export function useReadAutomationAutomationsIdGet<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadAutomationAutomationsIdGetQueryOptions(
		id,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadAutomationAutomationsIdGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadAutomationAutomationsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>
	> = ({ signal }) =>
		readAutomationAutomationsIdGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadAutomationAutomationsIdGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>
>;
export type ReadAutomationAutomationsIdGetSuspenseQueryError =
	HTTPValidationError;

export function useReadAutomationAutomationsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationAutomationsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationAutomationsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Automation
 */

export function useReadAutomationAutomationsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readAutomationAutomationsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadAutomationAutomationsIdGetSuspenseQueryOptions(
		id,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Read Automations
 */
export type readAutomationsAutomationsFilterPostResponse = {
	data: Automation[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadAutomationsAutomationsFilterPostUrl = () => {
	return `http://prefect.grose.click/api/automations/filter`;
};

export const readAutomationsAutomationsFilterPost = async (
	bodyReadAutomationsAutomationsFilterPost: BodyReadAutomationsAutomationsFilterPost,
	options?: RequestInit,
): Promise<readAutomationsAutomationsFilterPostResponse> => {
	const res = await fetch(getReadAutomationsAutomationsFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadAutomationsAutomationsFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readAutomationsAutomationsFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readAutomationsAutomationsFilterPostResponse;
};

export const getReadAutomationsAutomationsFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readAutomationsAutomationsFilterPost>>,
		TError,
		{ data: BodyReadAutomationsAutomationsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readAutomationsAutomationsFilterPost>>,
	TError,
	{ data: BodyReadAutomationsAutomationsFilterPost },
	TContext
> => {
	const mutationKey = ["readAutomationsAutomationsFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readAutomationsAutomationsFilterPost>>,
		{ data: BodyReadAutomationsAutomationsFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readAutomationsAutomationsFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadAutomationsAutomationsFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readAutomationsAutomationsFilterPost>>
>;
export type ReadAutomationsAutomationsFilterPostMutationBody =
	BodyReadAutomationsAutomationsFilterPost;
export type ReadAutomationsAutomationsFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Automations
 */
export const useReadAutomationsAutomationsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readAutomationsAutomationsFilterPost>>,
		TError,
		{ data: BodyReadAutomationsAutomationsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readAutomationsAutomationsFilterPost>>,
	TError,
	{ data: BodyReadAutomationsAutomationsFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadAutomationsAutomationsFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Count Automations
 */
export type countAutomationsAutomationsCountPostResponse = {
	data: number | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountAutomationsAutomationsCountPostUrl = () => {
	return `http://prefect.grose.click/api/automations/count`;
};

export const countAutomationsAutomationsCountPost = async (
	options?: RequestInit,
): Promise<countAutomationsAutomationsCountPostResponse> => {
	const res = await fetch(getCountAutomationsAutomationsCountPostUrl(), {
		...options,
		method: "POST",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countAutomationsAutomationsCountPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countAutomationsAutomationsCountPostResponse;
};

export const getCountAutomationsAutomationsCountPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countAutomationsAutomationsCountPost>>,
		TError,
		void,
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof countAutomationsAutomationsCountPost>>,
	TError,
	void,
	TContext
> => {
	const mutationKey = ["countAutomationsAutomationsCountPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof countAutomationsAutomationsCountPost>>,
		void
	> = () => {
		return countAutomationsAutomationsCountPost(fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CountAutomationsAutomationsCountPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof countAutomationsAutomationsCountPost>>
>;

export type CountAutomationsAutomationsCountPostMutationError =
	HTTPValidationError;

/**
 * @summary Count Automations
 */
export const useCountAutomationsAutomationsCountPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countAutomationsAutomationsCountPost>>,
		TError,
		void,
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countAutomationsAutomationsCountPost>>,
	TError,
	void,
	TContext
> => {
	const mutationOptions =
		getCountAutomationsAutomationsCountPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Read Automations Related To Resource
 */
export type readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetResponse =
	{
		data: Automation[] | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetUrl =
	(resourceId: string) => {
		return `http://prefect.grose.click/api/automations/related-to/${resourceId}`;
	};

export const readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet =
	async (
		resourceId: string,
		options?: RequestInit,
	): Promise<readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetResponse> => {
		const res = await fetch(
			getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetUrl(
				resourceId,
			),
			{
				...options,
				method: "GET",
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetResponse;
	};

export const getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetQueryKey =
	(resourceId: string) => {
		return [
			`http://prefect.grose.click/api/automations/related-to/${resourceId}`,
		] as const;
	};

export const getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
			>
		>,
		TError = HTTPValidationError,
	>(
		resourceId: string,
		options?: {
			query?: Partial<
				UseQueryOptions<
					Awaited<
						ReturnType<
							typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetQueryKey(
				resourceId,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
				>
			>
		> = ({ signal }) =>
			readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet(
				resourceId,
				{ signal, ...fetchOptions },
			);

		return {
			queryKey,
			queryFn,
			enabled: !!resourceId,
			...queryOptions,
		} as UseQueryOptions<
			Awaited<
				ReturnType<
					typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
			>
		>
	>;
export type ReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetQueryError =
	HTTPValidationError;

export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Automations Related To Resource
 */

export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetQueryOptions(
			resourceId,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<
				typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
			>
		>,
		TError = HTTPValidationError,
	>(
		resourceId: string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<
							typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetQueryKey(
				resourceId,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<
					typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
				>
			>
		> = ({ signal }) =>
			readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet(
				resourceId,
				{ signal, ...fetchOptions },
			);

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<
					typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
				>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
			>
		>
	>;
export type ReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspenseQueryError =
	HTTPValidationError;

export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Automations Related To Resource
 */

export function useReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspense<
	TData = Awaited<
		ReturnType<
			typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
		>
	>,
	TError = HTTPValidationError,
>(
	resourceId: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<
						typeof readAutomationsRelatedToResourceAutomationsRelatedToResourceIdGet
					>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadAutomationsRelatedToResourceAutomationsRelatedToResourceIdGetSuspenseQueryOptions(
			resourceId,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Delete Automations Owned By Resource
 */
export type deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteResponse =
	{
		data: HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getDeleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteUrl =
	(resourceId: string) => {
		return `http://prefect.grose.click/api/automations/owned-by/${resourceId}`;
	};

export const deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete =
	async (
		resourceId: string,
		options?: RequestInit,
	): Promise<deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteResponse> => {
		const res = await fetch(
			getDeleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteUrl(
				resourceId,
			),
			{
				...options,
				method: "DELETE",
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteResponse;
	};

export const getDeleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete
				>
			>,
			TError,
			{ resourceId: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete
			>
		>,
		TError,
		{ resourceId: string },
		TContext
	> => {
		const mutationKey = [
			"deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete
				>
			>,
			{ resourceId: string }
		> = (props) => {
			const { resourceId } = props ?? {};

			return deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete(
				resourceId,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DeleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete
			>
		>
	>;

export type DeleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Automations Owned By Resource
 */
export const useDeleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete
				>
			>,
			TError,
			{ resourceId: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationResult<
		Awaited<
			ReturnType<
				typeof deleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDelete
			>
		>,
		TError,
		{ resourceId: string },
		TContext
	> => {
		const mutationOptions =
			getDeleteAutomationsOwnedByResourceAutomationsOwnedByResourceIdDeleteMutationOptions(
				options,
			);

		return useMutation(mutationOptions);
	};
/**
 * @summary Validate Template
 */
export type validateTemplateTemplatesValidatePostResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getValidateTemplateTemplatesValidatePostUrl = () => {
	return `http://prefect.grose.click/api/templates/validate`;
};

export const validateTemplateTemplatesValidatePost = async (
	validateTemplateTemplatesValidatePostBody: string,
	options?: RequestInit,
): Promise<validateTemplateTemplatesValidatePostResponse> => {
	const res = await fetch(getValidateTemplateTemplatesValidatePostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(validateTemplateTemplatesValidatePostBody),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: validateTemplateTemplatesValidatePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as validateTemplateTemplatesValidatePostResponse;
};

export const getValidateTemplateTemplatesValidatePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof validateTemplateTemplatesValidatePost>>,
		TError,
		{ data: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof validateTemplateTemplatesValidatePost>>,
	TError,
	{ data: string },
	TContext
> => {
	const mutationKey = ["validateTemplateTemplatesValidatePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof validateTemplateTemplatesValidatePost>>,
		{ data: string }
	> = (props) => {
		const { data } = props ?? {};

		return validateTemplateTemplatesValidatePost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ValidateTemplateTemplatesValidatePostMutationResult = NonNullable<
	Awaited<ReturnType<typeof validateTemplateTemplatesValidatePost>>
>;
export type ValidateTemplateTemplatesValidatePostMutationBody = string;
export type ValidateTemplateTemplatesValidatePostMutationError =
	HTTPValidationError;

/**
 * @summary Validate Template
 */
export const useValidateTemplateTemplatesValidatePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof validateTemplateTemplatesValidatePost>>,
		TError,
		{ data: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof validateTemplateTemplatesValidatePost>>,
	TError,
	{ data: string },
	TContext
> => {
	const mutationOptions =
		getValidateTemplateTemplatesValidatePostMutationOptions(options);

	return useMutation(mutationOptions);
};
