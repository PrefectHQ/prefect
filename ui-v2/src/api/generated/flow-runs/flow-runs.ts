/**
 * Generated by orval v7.5.0 ðŸº
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	AverageFlowRunLatenessFlowRunsLatenessPost200,
	BodyAverageFlowRunLatenessFlowRunsLatenessPost,
	BodyCountFlowRunsFlowRunsCountPost,
	BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost,
	BodyCreateFlowRunInputFlowRunsIdInputPost,
	BodyFilterFlowRunInputFlowRunsIdInputFilterPost,
	BodyFlowRunHistoryFlowRunsHistoryPost,
	BodyPaginateFlowRunsFlowRunsPaginatePost,
	BodyReadFlowRunHistoryUiFlowRunsHistoryPost,
	BodyReadFlowRunsFlowRunsFilterPost,
	BodyResumeFlowRunFlowRunsIdResumePost,
	BodySetFlowRunStateFlowRunsIdSetStatePost,
	CountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost200,
	DependencyResult,
	FlowRunCreate,
	FlowRunInput,
	FlowRunPaginationResponse,
	FlowRunResponse,
	FlowRunUpdate,
	Graph,
	HTTPValidationError,
	HistoryResponse,
	OrchestrationResult,
	ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	SimpleFlowRun,
	UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody,
} from "../../models";

/**
 * Create a flow run. If a flow run with the same flow_id and
idempotency key already exists, the existing flow run will be returned.

If no state is provided, the flow run will be created in a PENDING state.
 * @summary Create Flow Run
 */
export type createFlowRunFlowRunsPostResponse = {
	data: FlowRunResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateFlowRunFlowRunsPostUrl = () => {
	return `http://prefect.grose.click/api/flow_runs/`;
};

export const createFlowRunFlowRunsPost = async (
	flowRunCreate: FlowRunCreate,
	options?: RequestInit,
): Promise<createFlowRunFlowRunsPostResponse> => {
	const res = await fetch(getCreateFlowRunFlowRunsPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(flowRunCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createFlowRunFlowRunsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createFlowRunFlowRunsPostResponse;
};

export const getCreateFlowRunFlowRunsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createFlowRunFlowRunsPost>>,
		TError,
		{ data: FlowRunCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createFlowRunFlowRunsPost>>,
	TError,
	{ data: FlowRunCreate },
	TContext
> => {
	const mutationKey = ["createFlowRunFlowRunsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createFlowRunFlowRunsPost>>,
		{ data: FlowRunCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createFlowRunFlowRunsPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateFlowRunFlowRunsPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createFlowRunFlowRunsPost>>
>;
export type CreateFlowRunFlowRunsPostMutationBody = FlowRunCreate;
export type CreateFlowRunFlowRunsPostMutationError = HTTPValidationError;

/**
 * @summary Create Flow Run
 */
export const useCreateFlowRunFlowRunsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createFlowRunFlowRunsPost>>,
		TError,
		{ data: FlowRunCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createFlowRunFlowRunsPost>>,
	TError,
	{ data: FlowRunCreate },
	TContext
> => {
	const mutationOptions = getCreateFlowRunFlowRunsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Updates a flow run.
 * @summary Update Flow Run
 */
export type updateFlowRunFlowRunsIdPatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateFlowRunFlowRunsIdPatchUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}`;
};

export const updateFlowRunFlowRunsIdPatch = async (
	id: string,
	flowRunUpdate: FlowRunUpdate,
	options?: RequestInit,
): Promise<updateFlowRunFlowRunsIdPatchResponse> => {
	const res = await fetch(getUpdateFlowRunFlowRunsIdPatchUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(flowRunUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateFlowRunFlowRunsIdPatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateFlowRunFlowRunsIdPatchResponse;
};

export const getUpdateFlowRunFlowRunsIdPatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateFlowRunFlowRunsIdPatch>>,
		TError,
		{ id: string; data: FlowRunUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateFlowRunFlowRunsIdPatch>>,
	TError,
	{ id: string; data: FlowRunUpdate },
	TContext
> => {
	const mutationKey = ["updateFlowRunFlowRunsIdPatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateFlowRunFlowRunsIdPatch>>,
		{ id: string; data: FlowRunUpdate }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateFlowRunFlowRunsIdPatch(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateFlowRunFlowRunsIdPatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateFlowRunFlowRunsIdPatch>>
>;
export type UpdateFlowRunFlowRunsIdPatchMutationBody = FlowRunUpdate;
export type UpdateFlowRunFlowRunsIdPatchMutationError = HTTPValidationError;

/**
 * @summary Update Flow Run
 */
export const useUpdateFlowRunFlowRunsIdPatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateFlowRunFlowRunsIdPatch>>,
		TError,
		{ id: string; data: FlowRunUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateFlowRunFlowRunsIdPatch>>,
	TError,
	{ id: string; data: FlowRunUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateFlowRunFlowRunsIdPatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a flow run by id.
 * @summary Read Flow Run
 */
export type readFlowRunFlowRunsIdGetResponse = {
	data: FlowRunResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadFlowRunFlowRunsIdGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}`;
};

export const readFlowRunFlowRunsIdGet = async (
	id: string,
	options?: RequestInit,
): Promise<readFlowRunFlowRunsIdGetResponse> => {
	const res = await fetch(getReadFlowRunFlowRunsIdGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readFlowRunFlowRunsIdGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readFlowRunFlowRunsIdGetResponse;
};

export const getReadFlowRunFlowRunsIdGetQueryKey = (id: string) => {
	return [`http://prefect.grose.click/api/flow_runs/${id}`] as const;
};

export const getReadFlowRunFlowRunsIdGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadFlowRunFlowRunsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>
	> = ({ signal }) => readFlowRunFlowRunsIdGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunFlowRunsIdGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>
>;
export type ReadFlowRunFlowRunsIdGetQueryError = HTTPValidationError;

export function useReadFlowRunFlowRunsIdGet<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunFlowRunsIdGet<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunFlowRunsIdGet<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run
 */

export function useReadFlowRunFlowRunsIdGet<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadFlowRunFlowRunsIdGetQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadFlowRunFlowRunsIdGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadFlowRunFlowRunsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>
	> = ({ signal }) => readFlowRunFlowRunsIdGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunFlowRunsIdGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>
>;
export type ReadFlowRunFlowRunsIdGetSuspenseQueryError = HTTPValidationError;

export function useReadFlowRunFlowRunsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunFlowRunsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunFlowRunsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run
 */

export function useReadFlowRunFlowRunsIdGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunFlowRunsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadFlowRunFlowRunsIdGetSuspenseQueryOptions(
		id,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Delete a flow run by id.
 * @summary Delete Flow Run
 */
export type deleteFlowRunFlowRunsIdDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteFlowRunFlowRunsIdDeleteUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}`;
};

export const deleteFlowRunFlowRunsIdDelete = async (
	id: string,
	options?: RequestInit,
): Promise<deleteFlowRunFlowRunsIdDeleteResponse> => {
	const res = await fetch(getDeleteFlowRunFlowRunsIdDeleteUrl(id), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteFlowRunFlowRunsIdDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteFlowRunFlowRunsIdDeleteResponse;
};

export const getDeleteFlowRunFlowRunsIdDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteFlowRunFlowRunsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteFlowRunFlowRunsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationKey = ["deleteFlowRunFlowRunsIdDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteFlowRunFlowRunsIdDelete>>,
		{ id: string }
	> = (props) => {
		const { id } = props ?? {};

		return deleteFlowRunFlowRunsIdDelete(id, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteFlowRunFlowRunsIdDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteFlowRunFlowRunsIdDelete>>
>;

export type DeleteFlowRunFlowRunsIdDeleteMutationError = HTTPValidationError;

/**
 * @summary Delete Flow Run
 */
export const useDeleteFlowRunFlowRunsIdDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteFlowRunFlowRunsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteFlowRunFlowRunsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getDeleteFlowRunFlowRunsIdDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Query for flow runs.
 * @summary Count Flow Runs
 */
export type countFlowRunsFlowRunsCountPostResponse = {
	data: number | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountFlowRunsFlowRunsCountPostUrl = () => {
	return `http://prefect.grose.click/api/flow_runs/count`;
};

export const countFlowRunsFlowRunsCountPost = async (
	bodyCountFlowRunsFlowRunsCountPost: BodyCountFlowRunsFlowRunsCountPost,
	options?: RequestInit,
): Promise<countFlowRunsFlowRunsCountPostResponse> => {
	const res = await fetch(getCountFlowRunsFlowRunsCountPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyCountFlowRunsFlowRunsCountPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countFlowRunsFlowRunsCountPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countFlowRunsFlowRunsCountPostResponse;
};

export const getCountFlowRunsFlowRunsCountPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countFlowRunsFlowRunsCountPost>>,
		TError,
		{ data: BodyCountFlowRunsFlowRunsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof countFlowRunsFlowRunsCountPost>>,
	TError,
	{ data: BodyCountFlowRunsFlowRunsCountPost },
	TContext
> => {
	const mutationKey = ["countFlowRunsFlowRunsCountPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof countFlowRunsFlowRunsCountPost>>,
		{ data: BodyCountFlowRunsFlowRunsCountPost }
	> = (props) => {
		const { data } = props ?? {};

		return countFlowRunsFlowRunsCountPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CountFlowRunsFlowRunsCountPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof countFlowRunsFlowRunsCountPost>>
>;
export type CountFlowRunsFlowRunsCountPostMutationBody =
	BodyCountFlowRunsFlowRunsCountPost;
export type CountFlowRunsFlowRunsCountPostMutationError = HTTPValidationError;

/**
 * @summary Count Flow Runs
 */
export const useCountFlowRunsFlowRunsCountPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countFlowRunsFlowRunsCountPost>>,
		TError,
		{ data: BodyCountFlowRunsFlowRunsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countFlowRunsFlowRunsCountPost>>,
	TError,
	{ data: BodyCountFlowRunsFlowRunsCountPost },
	TContext
> => {
	const mutationOptions =
		getCountFlowRunsFlowRunsCountPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Query for average flow-run lateness in seconds.
 * @summary Average Flow Run Lateness
 */
export type averageFlowRunLatenessFlowRunsLatenessPostResponse = {
	data: AverageFlowRunLatenessFlowRunsLatenessPost200 | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getAverageFlowRunLatenessFlowRunsLatenessPostUrl = () => {
	return `http://prefect.grose.click/api/flow_runs/lateness`;
};

export const averageFlowRunLatenessFlowRunsLatenessPost = async (
	bodyAverageFlowRunLatenessFlowRunsLatenessPost: BodyAverageFlowRunLatenessFlowRunsLatenessPost,
	options?: RequestInit,
): Promise<averageFlowRunLatenessFlowRunsLatenessPostResponse> => {
	const res = await fetch(getAverageFlowRunLatenessFlowRunsLatenessPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyAverageFlowRunLatenessFlowRunsLatenessPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: averageFlowRunLatenessFlowRunsLatenessPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as averageFlowRunLatenessFlowRunsLatenessPostResponse;
};

export const getAverageFlowRunLatenessFlowRunsLatenessPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof averageFlowRunLatenessFlowRunsLatenessPost>>,
		TError,
		{ data: BodyAverageFlowRunLatenessFlowRunsLatenessPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof averageFlowRunLatenessFlowRunsLatenessPost>>,
	TError,
	{ data: BodyAverageFlowRunLatenessFlowRunsLatenessPost },
	TContext
> => {
	const mutationKey = ["averageFlowRunLatenessFlowRunsLatenessPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof averageFlowRunLatenessFlowRunsLatenessPost>>,
		{ data: BodyAverageFlowRunLatenessFlowRunsLatenessPost }
	> = (props) => {
		const { data } = props ?? {};

		return averageFlowRunLatenessFlowRunsLatenessPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type AverageFlowRunLatenessFlowRunsLatenessPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof averageFlowRunLatenessFlowRunsLatenessPost>>
	>;
export type AverageFlowRunLatenessFlowRunsLatenessPostMutationBody =
	BodyAverageFlowRunLatenessFlowRunsLatenessPost;
export type AverageFlowRunLatenessFlowRunsLatenessPostMutationError =
	HTTPValidationError;

/**
 * @summary Average Flow Run Lateness
 */
export const useAverageFlowRunLatenessFlowRunsLatenessPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof averageFlowRunLatenessFlowRunsLatenessPost>>,
		TError,
		{ data: BodyAverageFlowRunLatenessFlowRunsLatenessPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof averageFlowRunLatenessFlowRunsLatenessPost>>,
	TError,
	{ data: BodyAverageFlowRunLatenessFlowRunsLatenessPost },
	TContext
> => {
	const mutationOptions =
		getAverageFlowRunLatenessFlowRunsLatenessPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Query for flow run history data across a given range and interval.
 * @summary Flow Run History
 */
export type flowRunHistoryFlowRunsHistoryPostResponse = {
	data: HistoryResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getFlowRunHistoryFlowRunsHistoryPostUrl = () => {
	return `http://prefect.grose.click/api/flow_runs/history`;
};

export const flowRunHistoryFlowRunsHistoryPost = async (
	bodyFlowRunHistoryFlowRunsHistoryPost: BodyFlowRunHistoryFlowRunsHistoryPost,
	options?: RequestInit,
): Promise<flowRunHistoryFlowRunsHistoryPostResponse> => {
	const res = await fetch(getFlowRunHistoryFlowRunsHistoryPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyFlowRunHistoryFlowRunsHistoryPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: flowRunHistoryFlowRunsHistoryPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as flowRunHistoryFlowRunsHistoryPostResponse;
};

export const getFlowRunHistoryFlowRunsHistoryPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof flowRunHistoryFlowRunsHistoryPost>>,
		TError,
		{ data: BodyFlowRunHistoryFlowRunsHistoryPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof flowRunHistoryFlowRunsHistoryPost>>,
	TError,
	{ data: BodyFlowRunHistoryFlowRunsHistoryPost },
	TContext
> => {
	const mutationKey = ["flowRunHistoryFlowRunsHistoryPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof flowRunHistoryFlowRunsHistoryPost>>,
		{ data: BodyFlowRunHistoryFlowRunsHistoryPost }
	> = (props) => {
		const { data } = props ?? {};

		return flowRunHistoryFlowRunsHistoryPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type FlowRunHistoryFlowRunsHistoryPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof flowRunHistoryFlowRunsHistoryPost>>
>;
export type FlowRunHistoryFlowRunsHistoryPostMutationBody =
	BodyFlowRunHistoryFlowRunsHistoryPost;
export type FlowRunHistoryFlowRunsHistoryPostMutationError =
	HTTPValidationError;

/**
 * @summary Flow Run History
 */
export const useFlowRunHistoryFlowRunsHistoryPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof flowRunHistoryFlowRunsHistoryPost>>,
		TError,
		{ data: BodyFlowRunHistoryFlowRunsHistoryPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof flowRunHistoryFlowRunsHistoryPost>>,
	TError,
	{ data: BodyFlowRunHistoryFlowRunsHistoryPost },
	TContext
> => {
	const mutationOptions =
		getFlowRunHistoryFlowRunsHistoryPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a task run dependency map for a given flow run.
 * @summary Read Flow Run Graph V1
 */
export type readFlowRunGraphV1FlowRunsIdGraphGetResponse = {
	data: DependencyResult[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadFlowRunGraphV1FlowRunsIdGraphGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/graph`;
};

export const readFlowRunGraphV1FlowRunsIdGraphGet = async (
	id: string,
	options?: RequestInit,
): Promise<readFlowRunGraphV1FlowRunsIdGraphGetResponse> => {
	const res = await fetch(getReadFlowRunGraphV1FlowRunsIdGraphGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readFlowRunGraphV1FlowRunsIdGraphGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readFlowRunGraphV1FlowRunsIdGraphGetResponse;
};

export const getReadFlowRunGraphV1FlowRunsIdGraphGetQueryKey = (id: string) => {
	return [`http://prefect.grose.click/api/flow_runs/${id}/graph`] as const;
};

export const getReadFlowRunGraphV1FlowRunsIdGraphGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadFlowRunGraphV1FlowRunsIdGraphGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>
	> = ({ signal }) =>
		readFlowRunGraphV1FlowRunsIdGraphGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunGraphV1FlowRunsIdGraphGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>
>;
export type ReadFlowRunGraphV1FlowRunsIdGraphGetQueryError =
	HTTPValidationError;

export function useReadFlowRunGraphV1FlowRunsIdGraphGet<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV1FlowRunsIdGraphGet<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV1FlowRunsIdGraphGet<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run Graph V1
 */

export function useReadFlowRunGraphV1FlowRunsIdGraphGet<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadFlowRunGraphV1FlowRunsIdGraphGetQueryOptions(
		id,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadFlowRunGraphV1FlowRunsIdGraphGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadFlowRunGraphV1FlowRunsIdGraphGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>
	> = ({ signal }) =>
		readFlowRunGraphV1FlowRunsIdGraphGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunGraphV1FlowRunsIdGraphGetSuspenseQueryResult =
	NonNullable<Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>>;
export type ReadFlowRunGraphV1FlowRunsIdGraphGetSuspenseQueryError =
	HTTPValidationError;

export function useReadFlowRunGraphV1FlowRunsIdGraphGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV1FlowRunsIdGraphGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV1FlowRunsIdGraphGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run Graph V1
 */

export function useReadFlowRunGraphV1FlowRunsIdGraphGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV1FlowRunsIdGraphGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadFlowRunGraphV1FlowRunsIdGraphGetSuspenseQueryOptions(id, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Get a graph of the tasks and subflow runs for the given flow run
 * @summary Read Flow Run Graph V2
 */
export type readFlowRunGraphV2FlowRunsIdGraphV2GetResponse = {
	data: Graph | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadFlowRunGraphV2FlowRunsIdGraphV2GetUrl = (
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
) => {
	const normalizedParams = new URLSearchParams();

	Object.entries(params || {}).forEach(([key, value]) => {
		if (value !== undefined) {
			normalizedParams.append(key, value === null ? "null" : value.toString());
		}
	});

	return normalizedParams.size
		? `http://prefect.grose.click/api/flow_runs/${id}/graph-v2?${normalizedParams.toString()}`
		: `http://prefect.grose.click/api/flow_runs/${id}/graph-v2`;
};

export const readFlowRunGraphV2FlowRunsIdGraphV2Get = async (
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: RequestInit,
): Promise<readFlowRunGraphV2FlowRunsIdGraphV2GetResponse> => {
	const res = await fetch(
		getReadFlowRunGraphV2FlowRunsIdGraphV2GetUrl(id, params),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readFlowRunGraphV2FlowRunsIdGraphV2GetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readFlowRunGraphV2FlowRunsIdGraphV2GetResponse;
};

export const getReadFlowRunGraphV2FlowRunsIdGraphV2GetQueryKey = (
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
) => {
	return [
		`http://prefect.grose.click/api/flow_runs/${id}/graph-v2`,
		...(params ? [params] : []),
	] as const;
};

export const getReadFlowRunGraphV2FlowRunsIdGraphV2GetQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadFlowRunGraphV2FlowRunsIdGraphV2GetQueryKey(id, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>
	> = ({ signal }) =>
		readFlowRunGraphV2FlowRunsIdGraphV2Get(id, params, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunGraphV2FlowRunsIdGraphV2GetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>
>;
export type ReadFlowRunGraphV2FlowRunsIdGraphV2GetQueryError =
	HTTPValidationError;

export function useReadFlowRunGraphV2FlowRunsIdGraphV2Get<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params: undefined | ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV2FlowRunsIdGraphV2Get<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV2FlowRunsIdGraphV2Get<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run Graph V2
 */

export function useReadFlowRunGraphV2FlowRunsIdGraphV2Get<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadFlowRunGraphV2FlowRunsIdGraphV2GetQueryOptions(
		id,
		params,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadFlowRunGraphV2FlowRunsIdGraphV2GetQueryKey(id, params);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>
	> = ({ signal }) =>
		readFlowRunGraphV2FlowRunsIdGraphV2Get(id, params, {
			signal,
			...fetchOptions,
		});

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>
	>;
export type ReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspenseQueryError =
	HTTPValidationError;

export function useReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params: undefined | ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run Graph V2
 */

export function useReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
	TError = HTTPValidationError,
>(
	id: string,
	params?: ReadFlowRunGraphV2FlowRunsIdGraphV2GetParams,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunGraphV2FlowRunsIdGraphV2Get>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadFlowRunGraphV2FlowRunsIdGraphV2GetSuspenseQueryOptions(
			id,
			params,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Resume a paused flow run.
 * @summary Resume Flow Run
 */
export type resumeFlowRunFlowRunsIdResumePostResponse = {
	data: OrchestrationResult | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getResumeFlowRunFlowRunsIdResumePostUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/resume`;
};

export const resumeFlowRunFlowRunsIdResumePost = async (
	id: string,
	bodyResumeFlowRunFlowRunsIdResumePost: BodyResumeFlowRunFlowRunsIdResumePost,
	options?: RequestInit,
): Promise<resumeFlowRunFlowRunsIdResumePostResponse> => {
	const res = await fetch(getResumeFlowRunFlowRunsIdResumePostUrl(id), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyResumeFlowRunFlowRunsIdResumePost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: resumeFlowRunFlowRunsIdResumePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as resumeFlowRunFlowRunsIdResumePostResponse;
};

export const getResumeFlowRunFlowRunsIdResumePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof resumeFlowRunFlowRunsIdResumePost>>,
		TError,
		{ id: string; data: BodyResumeFlowRunFlowRunsIdResumePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof resumeFlowRunFlowRunsIdResumePost>>,
	TError,
	{ id: string; data: BodyResumeFlowRunFlowRunsIdResumePost },
	TContext
> => {
	const mutationKey = ["resumeFlowRunFlowRunsIdResumePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof resumeFlowRunFlowRunsIdResumePost>>,
		{ id: string; data: BodyResumeFlowRunFlowRunsIdResumePost }
	> = (props) => {
		const { id, data } = props ?? {};

		return resumeFlowRunFlowRunsIdResumePost(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ResumeFlowRunFlowRunsIdResumePostMutationResult = NonNullable<
	Awaited<ReturnType<typeof resumeFlowRunFlowRunsIdResumePost>>
>;
export type ResumeFlowRunFlowRunsIdResumePostMutationBody =
	BodyResumeFlowRunFlowRunsIdResumePost;
export type ResumeFlowRunFlowRunsIdResumePostMutationError =
	HTTPValidationError;

/**
 * @summary Resume Flow Run
 */
export const useResumeFlowRunFlowRunsIdResumePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof resumeFlowRunFlowRunsIdResumePost>>,
		TError,
		{ id: string; data: BodyResumeFlowRunFlowRunsIdResumePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof resumeFlowRunFlowRunsIdResumePost>>,
	TError,
	{ id: string; data: BodyResumeFlowRunFlowRunsIdResumePost },
	TContext
> => {
	const mutationOptions =
		getResumeFlowRunFlowRunsIdResumePostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Query for flow runs.
 * @summary Read Flow Runs
 */
export type readFlowRunsFlowRunsFilterPostResponse = {
	data: FlowRunResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadFlowRunsFlowRunsFilterPostUrl = () => {
	return `http://prefect.grose.click/api/flow_runs/filter`;
};

export const readFlowRunsFlowRunsFilterPost = async (
	bodyReadFlowRunsFlowRunsFilterPost: BodyReadFlowRunsFlowRunsFilterPost,
	options?: RequestInit,
): Promise<readFlowRunsFlowRunsFilterPostResponse> => {
	const res = await fetch(getReadFlowRunsFlowRunsFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadFlowRunsFlowRunsFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readFlowRunsFlowRunsFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readFlowRunsFlowRunsFilterPostResponse;
};

export const getReadFlowRunsFlowRunsFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readFlowRunsFlowRunsFilterPost>>,
		TError,
		{ data: BodyReadFlowRunsFlowRunsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readFlowRunsFlowRunsFilterPost>>,
	TError,
	{ data: BodyReadFlowRunsFlowRunsFilterPost },
	TContext
> => {
	const mutationKey = ["readFlowRunsFlowRunsFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readFlowRunsFlowRunsFilterPost>>,
		{ data: BodyReadFlowRunsFlowRunsFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readFlowRunsFlowRunsFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadFlowRunsFlowRunsFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readFlowRunsFlowRunsFilterPost>>
>;
export type ReadFlowRunsFlowRunsFilterPostMutationBody =
	BodyReadFlowRunsFlowRunsFilterPost;
export type ReadFlowRunsFlowRunsFilterPostMutationError = HTTPValidationError;

/**
 * @summary Read Flow Runs
 */
export const useReadFlowRunsFlowRunsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readFlowRunsFlowRunsFilterPost>>,
		TError,
		{ data: BodyReadFlowRunsFlowRunsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readFlowRunsFlowRunsFilterPost>>,
	TError,
	{ data: BodyReadFlowRunsFlowRunsFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadFlowRunsFlowRunsFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Set a flow run state, invoking any orchestration rules.
 * @summary Set Flow Run State
 */
export type setFlowRunStateFlowRunsIdSetStatePostResponse = {
	data: OrchestrationResult | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getSetFlowRunStateFlowRunsIdSetStatePostUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/set_state`;
};

export const setFlowRunStateFlowRunsIdSetStatePost = async (
	id: string,
	bodySetFlowRunStateFlowRunsIdSetStatePost: BodySetFlowRunStateFlowRunsIdSetStatePost,
	options?: RequestInit,
): Promise<setFlowRunStateFlowRunsIdSetStatePostResponse> => {
	const res = await fetch(getSetFlowRunStateFlowRunsIdSetStatePostUrl(id), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodySetFlowRunStateFlowRunsIdSetStatePost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: setFlowRunStateFlowRunsIdSetStatePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as setFlowRunStateFlowRunsIdSetStatePostResponse;
};

export const getSetFlowRunStateFlowRunsIdSetStatePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof setFlowRunStateFlowRunsIdSetStatePost>>,
		TError,
		{ id: string; data: BodySetFlowRunStateFlowRunsIdSetStatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof setFlowRunStateFlowRunsIdSetStatePost>>,
	TError,
	{ id: string; data: BodySetFlowRunStateFlowRunsIdSetStatePost },
	TContext
> => {
	const mutationKey = ["setFlowRunStateFlowRunsIdSetStatePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof setFlowRunStateFlowRunsIdSetStatePost>>,
		{ id: string; data: BodySetFlowRunStateFlowRunsIdSetStatePost }
	> = (props) => {
		const { id, data } = props ?? {};

		return setFlowRunStateFlowRunsIdSetStatePost(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type SetFlowRunStateFlowRunsIdSetStatePostMutationResult = NonNullable<
	Awaited<ReturnType<typeof setFlowRunStateFlowRunsIdSetStatePost>>
>;
export type SetFlowRunStateFlowRunsIdSetStatePostMutationBody =
	BodySetFlowRunStateFlowRunsIdSetStatePost;
export type SetFlowRunStateFlowRunsIdSetStatePostMutationError =
	HTTPValidationError;

/**
 * @summary Set Flow Run State
 */
export const useSetFlowRunStateFlowRunsIdSetStatePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof setFlowRunStateFlowRunsIdSetStatePost>>,
		TError,
		{ id: string; data: BodySetFlowRunStateFlowRunsIdSetStatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof setFlowRunStateFlowRunsIdSetStatePost>>,
	TError,
	{ id: string; data: BodySetFlowRunStateFlowRunsIdSetStatePost },
	TContext
> => {
	const mutationOptions =
		getSetFlowRunStateFlowRunsIdSetStatePostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Create a key/value input for a flow run.
 * @summary Create Flow Run Input
 */
export type createFlowRunInputFlowRunsIdInputPostResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateFlowRunInputFlowRunsIdInputPostUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/input`;
};

export const createFlowRunInputFlowRunsIdInputPost = async (
	id: string,
	bodyCreateFlowRunInputFlowRunsIdInputPost: BodyCreateFlowRunInputFlowRunsIdInputPost,
	options?: RequestInit,
): Promise<createFlowRunInputFlowRunsIdInputPostResponse> => {
	const res = await fetch(getCreateFlowRunInputFlowRunsIdInputPostUrl(id), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyCreateFlowRunInputFlowRunsIdInputPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createFlowRunInputFlowRunsIdInputPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createFlowRunInputFlowRunsIdInputPostResponse;
};

export const getCreateFlowRunInputFlowRunsIdInputPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createFlowRunInputFlowRunsIdInputPost>>,
		TError,
		{ id: string; data: BodyCreateFlowRunInputFlowRunsIdInputPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createFlowRunInputFlowRunsIdInputPost>>,
	TError,
	{ id: string; data: BodyCreateFlowRunInputFlowRunsIdInputPost },
	TContext
> => {
	const mutationKey = ["createFlowRunInputFlowRunsIdInputPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createFlowRunInputFlowRunsIdInputPost>>,
		{ id: string; data: BodyCreateFlowRunInputFlowRunsIdInputPost }
	> = (props) => {
		const { id, data } = props ?? {};

		return createFlowRunInputFlowRunsIdInputPost(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateFlowRunInputFlowRunsIdInputPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createFlowRunInputFlowRunsIdInputPost>>
>;
export type CreateFlowRunInputFlowRunsIdInputPostMutationBody =
	BodyCreateFlowRunInputFlowRunsIdInputPost;
export type CreateFlowRunInputFlowRunsIdInputPostMutationError =
	HTTPValidationError;

/**
 * @summary Create Flow Run Input
 */
export const useCreateFlowRunInputFlowRunsIdInputPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createFlowRunInputFlowRunsIdInputPost>>,
		TError,
		{ id: string; data: BodyCreateFlowRunInputFlowRunsIdInputPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createFlowRunInputFlowRunsIdInputPost>>,
	TError,
	{ id: string; data: BodyCreateFlowRunInputFlowRunsIdInputPost },
	TContext
> => {
	const mutationOptions =
		getCreateFlowRunInputFlowRunsIdInputPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Filter flow run inputs by key prefix
 * @summary Filter Flow Run Input
 */
export type filterFlowRunInputFlowRunsIdInputFilterPostResponse = {
	data: FlowRunInput[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getFilterFlowRunInputFlowRunsIdInputFilterPostUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/input/filter`;
};

export const filterFlowRunInputFlowRunsIdInputFilterPost = async (
	id: string,
	bodyFilterFlowRunInputFlowRunsIdInputFilterPost: BodyFilterFlowRunInputFlowRunsIdInputFilterPost,
	options?: RequestInit,
): Promise<filterFlowRunInputFlowRunsIdInputFilterPostResponse> => {
	const res = await fetch(
		getFilterFlowRunInputFlowRunsIdInputFilterPostUrl(id),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(bodyFilterFlowRunInputFlowRunsIdInputFilterPost),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: filterFlowRunInputFlowRunsIdInputFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as filterFlowRunInputFlowRunsIdInputFilterPostResponse;
};

export const getFilterFlowRunInputFlowRunsIdInputFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof filterFlowRunInputFlowRunsIdInputFilterPost>>,
		TError,
		{ id: string; data: BodyFilterFlowRunInputFlowRunsIdInputFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof filterFlowRunInputFlowRunsIdInputFilterPost>>,
	TError,
	{ id: string; data: BodyFilterFlowRunInputFlowRunsIdInputFilterPost },
	TContext
> => {
	const mutationKey = ["filterFlowRunInputFlowRunsIdInputFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof filterFlowRunInputFlowRunsIdInputFilterPost>>,
		{ id: string; data: BodyFilterFlowRunInputFlowRunsIdInputFilterPost }
	> = (props) => {
		const { id, data } = props ?? {};

		return filterFlowRunInputFlowRunsIdInputFilterPost(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type FilterFlowRunInputFlowRunsIdInputFilterPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof filterFlowRunInputFlowRunsIdInputFilterPost>>
	>;
export type FilterFlowRunInputFlowRunsIdInputFilterPostMutationBody =
	BodyFilterFlowRunInputFlowRunsIdInputFilterPost;
export type FilterFlowRunInputFlowRunsIdInputFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Filter Flow Run Input
 */
export const useFilterFlowRunInputFlowRunsIdInputFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof filterFlowRunInputFlowRunsIdInputFilterPost>>,
		TError,
		{ id: string; data: BodyFilterFlowRunInputFlowRunsIdInputFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof filterFlowRunInputFlowRunsIdInputFilterPost>>,
	TError,
	{ id: string; data: BodyFilterFlowRunInputFlowRunsIdInputFilterPost },
	TContext
> => {
	const mutationOptions =
		getFilterFlowRunInputFlowRunsIdInputFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Create a value from a flow run input
 * @summary Read Flow Run Input
 */
export type readFlowRunInputFlowRunsIdInputKeyGetResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadFlowRunInputFlowRunsIdInputKeyGetUrl = (
	id: string,
	key: string,
) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/input/${key}`;
};

export const readFlowRunInputFlowRunsIdInputKeyGet = async (
	id: string,
	key: string,
	options?: RequestInit,
): Promise<readFlowRunInputFlowRunsIdInputKeyGetResponse> => {
	const res = await fetch(
		getReadFlowRunInputFlowRunsIdInputKeyGetUrl(id, key),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readFlowRunInputFlowRunsIdInputKeyGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readFlowRunInputFlowRunsIdInputKeyGetResponse;
};

export const getReadFlowRunInputFlowRunsIdInputKeyGetQueryKey = (
	id: string,
	key: string,
) => {
	return [
		`http://prefect.grose.click/api/flow_runs/${id}/input/${key}`,
	] as const;
};

export const getReadFlowRunInputFlowRunsIdInputKeyGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadFlowRunInputFlowRunsIdInputKeyGetQueryKey(id, key);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>
	> = ({ signal }) =>
		readFlowRunInputFlowRunsIdInputKeyGet(id, key, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!(id && key),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunInputFlowRunsIdInputKeyGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>
>;
export type ReadFlowRunInputFlowRunsIdInputKeyGetQueryError =
	HTTPValidationError;

export function useReadFlowRunInputFlowRunsIdInputKeyGet<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunInputFlowRunsIdInputKeyGet<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
					TError,
					Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunInputFlowRunsIdInputKeyGet<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run Input
 */

export function useReadFlowRunInputFlowRunsIdInputKeyGet<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadFlowRunInputFlowRunsIdInputKeyGetQueryOptions(
		id,
		key,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadFlowRunInputFlowRunsIdInputKeyGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadFlowRunInputFlowRunsIdInputKeyGetQueryKey(id, key);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>
	> = ({ signal }) =>
		readFlowRunInputFlowRunsIdInputKeyGet(id, key, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadFlowRunInputFlowRunsIdInputKeyGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>
	>;
export type ReadFlowRunInputFlowRunsIdInputKeyGetSuspenseQueryError =
	HTTPValidationError;

export function useReadFlowRunInputFlowRunsIdInputKeyGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunInputFlowRunsIdInputKeyGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadFlowRunInputFlowRunsIdInputKeyGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Flow Run Input
 */

export function useReadFlowRunInputFlowRunsIdInputKeyGetSuspense<
	TData = Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	key: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readFlowRunInputFlowRunsIdInputKeyGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadFlowRunInputFlowRunsIdInputKeyGetSuspenseQueryOptions(
			id,
			key,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Delete a flow run input
 * @summary Delete Flow Run Input
 */
export type deleteFlowRunInputFlowRunsIdInputKeyDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteFlowRunInputFlowRunsIdInputKeyDeleteUrl = (
	id: string,
	key: string,
) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/input/${key}`;
};

export const deleteFlowRunInputFlowRunsIdInputKeyDelete = async (
	id: string,
	key: string,
	options?: RequestInit,
): Promise<deleteFlowRunInputFlowRunsIdInputKeyDeleteResponse> => {
	const res = await fetch(
		getDeleteFlowRunInputFlowRunsIdInputKeyDeleteUrl(id, key),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteFlowRunInputFlowRunsIdInputKeyDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteFlowRunInputFlowRunsIdInputKeyDeleteResponse;
};

export const getDeleteFlowRunInputFlowRunsIdInputKeyDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteFlowRunInputFlowRunsIdInputKeyDelete>>,
		TError,
		{ id: string; key: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteFlowRunInputFlowRunsIdInputKeyDelete>>,
	TError,
	{ id: string; key: string },
	TContext
> => {
	const mutationKey = ["deleteFlowRunInputFlowRunsIdInputKeyDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteFlowRunInputFlowRunsIdInputKeyDelete>>,
		{ id: string; key: string }
	> = (props) => {
		const { id, key } = props ?? {};

		return deleteFlowRunInputFlowRunsIdInputKeyDelete(id, key, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteFlowRunInputFlowRunsIdInputKeyDeleteMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof deleteFlowRunInputFlowRunsIdInputKeyDelete>>
	>;

export type DeleteFlowRunInputFlowRunsIdInputKeyDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Flow Run Input
 */
export const useDeleteFlowRunInputFlowRunsIdInputKeyDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteFlowRunInputFlowRunsIdInputKeyDelete>>,
		TError,
		{ id: string; key: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteFlowRunInputFlowRunsIdInputKeyDelete>>,
	TError,
	{ id: string; key: string },
	TContext
> => {
	const mutationOptions =
		getDeleteFlowRunInputFlowRunsIdInputKeyDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Pagination query for flow runs.
 * @summary Paginate Flow Runs
 */
export type paginateFlowRunsFlowRunsPaginatePostResponse = {
	data: FlowRunPaginationResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getPaginateFlowRunsFlowRunsPaginatePostUrl = () => {
	return `http://prefect.grose.click/api/flow_runs/paginate`;
};

export const paginateFlowRunsFlowRunsPaginatePost = async (
	bodyPaginateFlowRunsFlowRunsPaginatePost: BodyPaginateFlowRunsFlowRunsPaginatePost,
	options?: RequestInit,
): Promise<paginateFlowRunsFlowRunsPaginatePostResponse> => {
	const res = await fetch(getPaginateFlowRunsFlowRunsPaginatePostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyPaginateFlowRunsFlowRunsPaginatePost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: paginateFlowRunsFlowRunsPaginatePostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as paginateFlowRunsFlowRunsPaginatePostResponse;
};

export const getPaginateFlowRunsFlowRunsPaginatePostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof paginateFlowRunsFlowRunsPaginatePost>>,
		TError,
		{ data: BodyPaginateFlowRunsFlowRunsPaginatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof paginateFlowRunsFlowRunsPaginatePost>>,
	TError,
	{ data: BodyPaginateFlowRunsFlowRunsPaginatePost },
	TContext
> => {
	const mutationKey = ["paginateFlowRunsFlowRunsPaginatePost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof paginateFlowRunsFlowRunsPaginatePost>>,
		{ data: BodyPaginateFlowRunsFlowRunsPaginatePost }
	> = (props) => {
		const { data } = props ?? {};

		return paginateFlowRunsFlowRunsPaginatePost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type PaginateFlowRunsFlowRunsPaginatePostMutationResult = NonNullable<
	Awaited<ReturnType<typeof paginateFlowRunsFlowRunsPaginatePost>>
>;
export type PaginateFlowRunsFlowRunsPaginatePostMutationBody =
	BodyPaginateFlowRunsFlowRunsPaginatePost;
export type PaginateFlowRunsFlowRunsPaginatePostMutationError =
	HTTPValidationError;

/**
 * @summary Paginate Flow Runs
 */
export const usePaginateFlowRunsFlowRunsPaginatePost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof paginateFlowRunsFlowRunsPaginatePost>>,
		TError,
		{ data: BodyPaginateFlowRunsFlowRunsPaginatePost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof paginateFlowRunsFlowRunsPaginatePost>>,
	TError,
	{ data: BodyPaginateFlowRunsFlowRunsPaginatePost },
	TContext
> => {
	const mutationOptions =
		getPaginateFlowRunsFlowRunsPaginatePostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Download all flow run logs as a CSV file, collecting all logs until there are no more logs to retrieve.
 * @summary Download Logs
 */
export type downloadLogsFlowRunsIdLogsDownloadGetResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDownloadLogsFlowRunsIdLogsDownloadGetUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/logs/download`;
};

export const downloadLogsFlowRunsIdLogsDownloadGet = async (
	id: string,
	options?: RequestInit,
): Promise<downloadLogsFlowRunsIdLogsDownloadGetResponse> => {
	const res = await fetch(getDownloadLogsFlowRunsIdLogsDownloadGetUrl(id), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: downloadLogsFlowRunsIdLogsDownloadGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as downloadLogsFlowRunsIdLogsDownloadGetResponse;
};

export const getDownloadLogsFlowRunsIdLogsDownloadGetQueryKey = (
	id: string,
) => {
	return [
		`http://prefect.grose.click/api/flow_runs/${id}/logs/download`,
	] as const;
};

export const getDownloadLogsFlowRunsIdLogsDownloadGetQueryOptions = <
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getDownloadLogsFlowRunsIdLogsDownloadGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>
	> = ({ signal }) =>
		downloadLogsFlowRunsIdLogsDownloadGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DownloadLogsFlowRunsIdLogsDownloadGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>
>;
export type DownloadLogsFlowRunsIdLogsDownloadGetQueryError =
	HTTPValidationError;

export function useDownloadLogsFlowRunsIdLogsDownloadGet<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
					TError,
					Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadLogsFlowRunsIdLogsDownloadGet<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
					TError,
					Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadLogsFlowRunsIdLogsDownloadGet<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download Logs
 */

export function useDownloadLogsFlowRunsIdLogsDownloadGet<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getDownloadLogsFlowRunsIdLogsDownloadGetQueryOptions(
		id,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getDownloadLogsFlowRunsIdLogsDownloadGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getDownloadLogsFlowRunsIdLogsDownloadGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>
	> = ({ signal }) =>
		downloadLogsFlowRunsIdLogsDownloadGet(id, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type DownloadLogsFlowRunsIdLogsDownloadGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>
	>;
export type DownloadLogsFlowRunsIdLogsDownloadGetSuspenseQueryError =
	HTTPValidationError;

export function useDownloadLogsFlowRunsIdLogsDownloadGetSuspense<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadLogsFlowRunsIdLogsDownloadGetSuspense<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useDownloadLogsFlowRunsIdLogsDownloadGetSuspense<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Download Logs
 */

export function useDownloadLogsFlowRunsIdLogsDownloadGetSuspense<
	TData = Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof downloadLogsFlowRunsIdLogsDownloadGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getDownloadLogsFlowRunsIdLogsDownloadGetSuspenseQueryOptions(id, options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Update the labels of a flow run.
 * @summary Update Flow Run Labels
 */
export type updateFlowRunLabelsFlowRunsIdLabelsPatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateFlowRunLabelsFlowRunsIdLabelsPatchUrl = (id: string) => {
	return `http://prefect.grose.click/api/flow_runs/${id}/labels`;
};

export const updateFlowRunLabelsFlowRunsIdLabelsPatch = async (
	id: string,
	updateFlowRunLabelsFlowRunsIdLabelsPatchBody: UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody,
	options?: RequestInit,
): Promise<updateFlowRunLabelsFlowRunsIdLabelsPatchResponse> => {
	const res = await fetch(getUpdateFlowRunLabelsFlowRunsIdLabelsPatchUrl(id), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(updateFlowRunLabelsFlowRunsIdLabelsPatchBody),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateFlowRunLabelsFlowRunsIdLabelsPatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateFlowRunLabelsFlowRunsIdLabelsPatchResponse;
};

export const getUpdateFlowRunLabelsFlowRunsIdLabelsPatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateFlowRunLabelsFlowRunsIdLabelsPatch>>,
		TError,
		{ id: string; data: UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateFlowRunLabelsFlowRunsIdLabelsPatch>>,
	TError,
	{ id: string; data: UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody },
	TContext
> => {
	const mutationKey = ["updateFlowRunLabelsFlowRunsIdLabelsPatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateFlowRunLabelsFlowRunsIdLabelsPatch>>,
		{ id: string; data: UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody }
	> = (props) => {
		const { id, data } = props ?? {};

		return updateFlowRunLabelsFlowRunsIdLabelsPatch(id, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateFlowRunLabelsFlowRunsIdLabelsPatchMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof updateFlowRunLabelsFlowRunsIdLabelsPatch>>
	>;
export type UpdateFlowRunLabelsFlowRunsIdLabelsPatchMutationBody =
	UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody;
export type UpdateFlowRunLabelsFlowRunsIdLabelsPatchMutationError =
	HTTPValidationError;

/**
 * @summary Update Flow Run Labels
 */
export const useUpdateFlowRunLabelsFlowRunsIdLabelsPatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateFlowRunLabelsFlowRunsIdLabelsPatch>>,
		TError,
		{ id: string; data: UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateFlowRunLabelsFlowRunsIdLabelsPatch>>,
	TError,
	{ id: string; data: UpdateFlowRunLabelsFlowRunsIdLabelsPatchBody },
	TContext
> => {
	const mutationOptions =
		getUpdateFlowRunLabelsFlowRunsIdLabelsPatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Read Flow Run History
 */
export type readFlowRunHistoryUiFlowRunsHistoryPostResponse = {
	data: SimpleFlowRun[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadFlowRunHistoryUiFlowRunsHistoryPostUrl = () => {
	return `http://prefect.grose.click/api/ui/flow_runs/history`;
};

export const readFlowRunHistoryUiFlowRunsHistoryPost = async (
	bodyReadFlowRunHistoryUiFlowRunsHistoryPost: BodyReadFlowRunHistoryUiFlowRunsHistoryPost,
	options?: RequestInit,
): Promise<readFlowRunHistoryUiFlowRunsHistoryPostResponse> => {
	const res = await fetch(getReadFlowRunHistoryUiFlowRunsHistoryPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadFlowRunHistoryUiFlowRunsHistoryPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readFlowRunHistoryUiFlowRunsHistoryPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readFlowRunHistoryUiFlowRunsHistoryPostResponse;
};

export const getReadFlowRunHistoryUiFlowRunsHistoryPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readFlowRunHistoryUiFlowRunsHistoryPost>>,
		TError,
		{ data: BodyReadFlowRunHistoryUiFlowRunsHistoryPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readFlowRunHistoryUiFlowRunsHistoryPost>>,
	TError,
	{ data: BodyReadFlowRunHistoryUiFlowRunsHistoryPost },
	TContext
> => {
	const mutationKey = ["readFlowRunHistoryUiFlowRunsHistoryPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readFlowRunHistoryUiFlowRunsHistoryPost>>,
		{ data: BodyReadFlowRunHistoryUiFlowRunsHistoryPost }
	> = (props) => {
		const { data } = props ?? {};

		return readFlowRunHistoryUiFlowRunsHistoryPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadFlowRunHistoryUiFlowRunsHistoryPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readFlowRunHistoryUiFlowRunsHistoryPost>>
>;
export type ReadFlowRunHistoryUiFlowRunsHistoryPostMutationBody =
	BodyReadFlowRunHistoryUiFlowRunsHistoryPost;
export type ReadFlowRunHistoryUiFlowRunsHistoryPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Flow Run History
 */
export const useReadFlowRunHistoryUiFlowRunsHistoryPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readFlowRunHistoryUiFlowRunsHistoryPost>>,
		TError,
		{ data: BodyReadFlowRunHistoryUiFlowRunsHistoryPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readFlowRunHistoryUiFlowRunsHistoryPost>>,
	TError,
	{ data: BodyReadFlowRunHistoryUiFlowRunsHistoryPost },
	TContext
> => {
	const mutationOptions =
		getReadFlowRunHistoryUiFlowRunsHistoryPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get task run counts by flow run id.
 * @summary Count Task Runs By Flow Run
 */
export type countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostResponse = {
	data:
		| CountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost200
		| HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostUrl = () => {
	return `http://prefect.grose.click/api/ui/flow_runs/count-task-runs`;
};

export const countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost = async (
	bodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost: BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost,
	options?: RequestInit,
): Promise<countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostResponse> => {
	const res = await fetch(
		getCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostResponse;
};

export const getCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost>
			>,
			TError,
			{ data: BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost>
		>,
		TError,
		{ data: BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost },
		TContext
	> => {
		const mutationKey = ["countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost>
			>,
			{ data: BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost }
		> = (props) => {
			const { data } = props ?? {};

			return countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type CountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost>
		>
	>;
export type CountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostMutationBody =
	BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost;
export type CountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostMutationError =
	HTTPValidationError;

/**
 * @summary Count Task Runs By Flow Run
 */
export const useCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost>
		>,
		TError,
		{ data: BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost>>,
	TError,
	{ data: BodyCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPost },
	TContext
> => {
	const mutationOptions =
		getCountTaskRunsByFlowRunUiFlowRunsCountTaskRunsPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
