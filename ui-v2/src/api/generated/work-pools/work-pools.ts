/**
 * Generated by orval v7.5.0 ðŸº
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BodyCountWorkPoolsWorkPoolsCountPost,
	BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost,
	BodyReadWorkPoolsWorkPoolsFilterPost,
	BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost,
	BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost,
	BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost,
	HTTPValidationError,
	WorkPool,
	WorkPoolCreate,
	WorkPoolUpdate,
	WorkQueueCreate,
	WorkQueueResponse,
	WorkQueueUpdate,
	WorkerFlowRunResponse,
	WorkerResponse,
} from "../../models";

/**
 * Creates a new work pool. If a work pool with the same
name already exists, an error will be raised.
 * @summary Create Work Pool
 */
export type createWorkPoolWorkPoolsPostResponse = {
	data: WorkPool | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateWorkPoolWorkPoolsPostUrl = () => {
	return `http://prefect.grose.click/api/work_pools/`;
};

export const createWorkPoolWorkPoolsPost = async (
	workPoolCreate: WorkPoolCreate,
	options?: RequestInit,
): Promise<createWorkPoolWorkPoolsPostResponse> => {
	const res = await fetch(getCreateWorkPoolWorkPoolsPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(workPoolCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createWorkPoolWorkPoolsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createWorkPoolWorkPoolsPostResponse;
};

export const getCreateWorkPoolWorkPoolsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createWorkPoolWorkPoolsPost>>,
		TError,
		{ data: WorkPoolCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createWorkPoolWorkPoolsPost>>,
	TError,
	{ data: WorkPoolCreate },
	TContext
> => {
	const mutationKey = ["createWorkPoolWorkPoolsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createWorkPoolWorkPoolsPost>>,
		{ data: WorkPoolCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createWorkPoolWorkPoolsPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateWorkPoolWorkPoolsPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof createWorkPoolWorkPoolsPost>>
>;
export type CreateWorkPoolWorkPoolsPostMutationBody = WorkPoolCreate;
export type CreateWorkPoolWorkPoolsPostMutationError = HTTPValidationError;

/**
 * @summary Create Work Pool
 */
export const useCreateWorkPoolWorkPoolsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createWorkPoolWorkPoolsPost>>,
		TError,
		{ data: WorkPoolCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createWorkPoolWorkPoolsPost>>,
	TError,
	{ data: WorkPoolCreate },
	TContext
> => {
	const mutationOptions =
		getCreateWorkPoolWorkPoolsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Read a work pool by name
 * @summary Read Work Pool
 */
export type readWorkPoolWorkPoolsNameGetResponse = {
	data: WorkPool | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkPoolWorkPoolsNameGetUrl = (name: string) => {
	return `http://prefect.grose.click/api/work_pools/${name}`;
};

export const readWorkPoolWorkPoolsNameGet = async (
	name: string,
	options?: RequestInit,
): Promise<readWorkPoolWorkPoolsNameGetResponse> => {
	const res = await fetch(getReadWorkPoolWorkPoolsNameGetUrl(name), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkPoolWorkPoolsNameGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkPoolWorkPoolsNameGetResponse;
};

export const getReadWorkPoolWorkPoolsNameGetQueryKey = (name: string) => {
	return [`http://prefect.grose.click/api/work_pools/${name}`] as const;
};

export const getReadWorkPoolWorkPoolsNameGetQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadWorkPoolWorkPoolsNameGetQueryKey(name);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>
	> = ({ signal }) =>
		readWorkPoolWorkPoolsNameGet(name, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!name,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkPoolWorkPoolsNameGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>
>;
export type ReadWorkPoolWorkPoolsNameGetQueryError = HTTPValidationError;

export function useReadWorkPoolWorkPoolsNameGet<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkPoolWorkPoolsNameGet<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
					TError,
					Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkPoolWorkPoolsNameGet<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Pool
 */

export function useReadWorkPoolWorkPoolsNameGet<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadWorkPoolWorkPoolsNameGetQueryOptions(
		name,
		options,
	);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadWorkPoolWorkPoolsNameGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getReadWorkPoolWorkPoolsNameGetQueryKey(name);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>
	> = ({ signal }) =>
		readWorkPoolWorkPoolsNameGet(name, { signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkPoolWorkPoolsNameGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>
>;
export type ReadWorkPoolWorkPoolsNameGetSuspenseQueryError =
	HTTPValidationError;

export function useReadWorkPoolWorkPoolsNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkPoolWorkPoolsNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkPoolWorkPoolsNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Pool
 */

export function useReadWorkPoolWorkPoolsNameGetSuspense<
	TData = Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
	TError = HTTPValidationError,
>(
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readWorkPoolWorkPoolsNameGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getReadWorkPoolWorkPoolsNameGetSuspenseQueryOptions(
		name,
		options,
	);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Update a work pool
 * @summary Update Work Pool
 */
export type updateWorkPoolWorkPoolsNamePatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateWorkPoolWorkPoolsNamePatchUrl = (name: string) => {
	return `http://prefect.grose.click/api/work_pools/${name}`;
};

export const updateWorkPoolWorkPoolsNamePatch = async (
	name: string,
	workPoolUpdate: WorkPoolUpdate,
	options?: RequestInit,
): Promise<updateWorkPoolWorkPoolsNamePatchResponse> => {
	const res = await fetch(getUpdateWorkPoolWorkPoolsNamePatchUrl(name), {
		...options,
		method: "PATCH",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(workPoolUpdate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateWorkPoolWorkPoolsNamePatchResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateWorkPoolWorkPoolsNamePatchResponse;
};

export const getUpdateWorkPoolWorkPoolsNamePatchMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateWorkPoolWorkPoolsNamePatch>>,
		TError,
		{ name: string; data: WorkPoolUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof updateWorkPoolWorkPoolsNamePatch>>,
	TError,
	{ name: string; data: WorkPoolUpdate },
	TContext
> => {
	const mutationKey = ["updateWorkPoolWorkPoolsNamePatch"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof updateWorkPoolWorkPoolsNamePatch>>,
		{ name: string; data: WorkPoolUpdate }
	> = (props) => {
		const { name, data } = props ?? {};

		return updateWorkPoolWorkPoolsNamePatch(name, data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type UpdateWorkPoolWorkPoolsNamePatchMutationResult = NonNullable<
	Awaited<ReturnType<typeof updateWorkPoolWorkPoolsNamePatch>>
>;
export type UpdateWorkPoolWorkPoolsNamePatchMutationBody = WorkPoolUpdate;
export type UpdateWorkPoolWorkPoolsNamePatchMutationError = HTTPValidationError;

/**
 * @summary Update Work Pool
 */
export const useUpdateWorkPoolWorkPoolsNamePatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof updateWorkPoolWorkPoolsNamePatch>>,
		TError,
		{ name: string; data: WorkPoolUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof updateWorkPoolWorkPoolsNamePatch>>,
	TError,
	{ name: string; data: WorkPoolUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateWorkPoolWorkPoolsNamePatchMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Delete a work pool
 * @summary Delete Work Pool
 */
export type deleteWorkPoolWorkPoolsNameDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteWorkPoolWorkPoolsNameDeleteUrl = (name: string) => {
	return `http://prefect.grose.click/api/work_pools/${name}`;
};

export const deleteWorkPoolWorkPoolsNameDelete = async (
	name: string,
	options?: RequestInit,
): Promise<deleteWorkPoolWorkPoolsNameDeleteResponse> => {
	const res = await fetch(getDeleteWorkPoolWorkPoolsNameDeleteUrl(name), {
		...options,
		method: "DELETE",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteWorkPoolWorkPoolsNameDeleteResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteWorkPoolWorkPoolsNameDeleteResponse;
};

export const getDeleteWorkPoolWorkPoolsNameDeleteMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteWorkPoolWorkPoolsNameDelete>>,
		TError,
		{ name: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof deleteWorkPoolWorkPoolsNameDelete>>,
	TError,
	{ name: string },
	TContext
> => {
	const mutationKey = ["deleteWorkPoolWorkPoolsNameDelete"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof deleteWorkPoolWorkPoolsNameDelete>>,
		{ name: string }
	> = (props) => {
		const { name } = props ?? {};

		return deleteWorkPoolWorkPoolsNameDelete(name, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteWorkPoolWorkPoolsNameDeleteMutationResult = NonNullable<
	Awaited<ReturnType<typeof deleteWorkPoolWorkPoolsNameDelete>>
>;

export type DeleteWorkPoolWorkPoolsNameDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Work Pool
 */
export const useDeleteWorkPoolWorkPoolsNameDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteWorkPoolWorkPoolsNameDelete>>,
		TError,
		{ name: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteWorkPoolWorkPoolsNameDelete>>,
	TError,
	{ name: string },
	TContext
> => {
	const mutationOptions =
		getDeleteWorkPoolWorkPoolsNameDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Read multiple work pools
 * @summary Read Work Pools
 */
export type readWorkPoolsWorkPoolsFilterPostResponse = {
	data: WorkPool[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkPoolsWorkPoolsFilterPostUrl = () => {
	return `http://prefect.grose.click/api/work_pools/filter`;
};

export const readWorkPoolsWorkPoolsFilterPost = async (
	bodyReadWorkPoolsWorkPoolsFilterPost: BodyReadWorkPoolsWorkPoolsFilterPost,
	options?: RequestInit,
): Promise<readWorkPoolsWorkPoolsFilterPostResponse> => {
	const res = await fetch(getReadWorkPoolsWorkPoolsFilterPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyReadWorkPoolsWorkPoolsFilterPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkPoolsWorkPoolsFilterPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkPoolsWorkPoolsFilterPostResponse;
};

export const getReadWorkPoolsWorkPoolsFilterPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readWorkPoolsWorkPoolsFilterPost>>,
		TError,
		{ data: BodyReadWorkPoolsWorkPoolsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof readWorkPoolsWorkPoolsFilterPost>>,
	TError,
	{ data: BodyReadWorkPoolsWorkPoolsFilterPost },
	TContext
> => {
	const mutationKey = ["readWorkPoolsWorkPoolsFilterPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof readWorkPoolsWorkPoolsFilterPost>>,
		{ data: BodyReadWorkPoolsWorkPoolsFilterPost }
	> = (props) => {
		const { data } = props ?? {};

		return readWorkPoolsWorkPoolsFilterPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type ReadWorkPoolsWorkPoolsFilterPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof readWorkPoolsWorkPoolsFilterPost>>
>;
export type ReadWorkPoolsWorkPoolsFilterPostMutationBody =
	BodyReadWorkPoolsWorkPoolsFilterPost;
export type ReadWorkPoolsWorkPoolsFilterPostMutationError = HTTPValidationError;

/**
 * @summary Read Work Pools
 */
export const useReadWorkPoolsWorkPoolsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof readWorkPoolsWorkPoolsFilterPost>>,
		TError,
		{ data: BodyReadWorkPoolsWorkPoolsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readWorkPoolsWorkPoolsFilterPost>>,
	TError,
	{ data: BodyReadWorkPoolsWorkPoolsFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadWorkPoolsWorkPoolsFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Count work pools
 * @summary Count Work Pools
 */
export type countWorkPoolsWorkPoolsCountPostResponse = {
	data: number | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCountWorkPoolsWorkPoolsCountPostUrl = () => {
	return `http://prefect.grose.click/api/work_pools/count`;
};

export const countWorkPoolsWorkPoolsCountPost = async (
	bodyCountWorkPoolsWorkPoolsCountPost: BodyCountWorkPoolsWorkPoolsCountPost,
	options?: RequestInit,
): Promise<countWorkPoolsWorkPoolsCountPostResponse> => {
	const res = await fetch(getCountWorkPoolsWorkPoolsCountPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(bodyCountWorkPoolsWorkPoolsCountPost),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: countWorkPoolsWorkPoolsCountPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as countWorkPoolsWorkPoolsCountPostResponse;
};

export const getCountWorkPoolsWorkPoolsCountPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countWorkPoolsWorkPoolsCountPost>>,
		TError,
		{ data: BodyCountWorkPoolsWorkPoolsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof countWorkPoolsWorkPoolsCountPost>>,
	TError,
	{ data: BodyCountWorkPoolsWorkPoolsCountPost },
	TContext
> => {
	const mutationKey = ["countWorkPoolsWorkPoolsCountPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof countWorkPoolsWorkPoolsCountPost>>,
		{ data: BodyCountWorkPoolsWorkPoolsCountPost }
	> = (props) => {
		const { data } = props ?? {};

		return countWorkPoolsWorkPoolsCountPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CountWorkPoolsWorkPoolsCountPostMutationResult = NonNullable<
	Awaited<ReturnType<typeof countWorkPoolsWorkPoolsCountPost>>
>;
export type CountWorkPoolsWorkPoolsCountPostMutationBody =
	BodyCountWorkPoolsWorkPoolsCountPost;
export type CountWorkPoolsWorkPoolsCountPostMutationError = HTTPValidationError;

/**
 * @summary Count Work Pools
 */
export const useCountWorkPoolsWorkPoolsCountPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof countWorkPoolsWorkPoolsCountPost>>,
		TError,
		{ data: BodyCountWorkPoolsWorkPoolsCountPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof countWorkPoolsWorkPoolsCountPost>>,
	TError,
	{ data: BodyCountWorkPoolsWorkPoolsCountPost },
	TContext
> => {
	const mutationOptions =
		getCountWorkPoolsWorkPoolsCountPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Load scheduled runs for a worker
 * @summary Get Scheduled Flow Runs
 */
export type getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponse =
	{
		data: WorkerFlowRunResponse[] | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostUrl = (
	name: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${name}/get_scheduled_flow_runs`;
};

export const getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost = async (
	name: string,
	bodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost: BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost,
	options?: RequestInit,
): Promise<getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponse> => {
	const res = await fetch(
		getGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostUrl(name),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostResponse;
};

export const getGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost
				>
			>,
			TError,
			{
				name: string;
				data: BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost;
			},
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost
			>
		>,
		TError,
		{
			name: string;
			data: BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost;
		},
		TContext
	> => {
		const mutationKey = [
			"getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost
				>
			>,
			{
				name: string;
				data: BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost;
			}
		> = (props) => {
			const { name, data } = props ?? {};

			return getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost(
				name,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type GetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost
			>
		>
	>;
export type GetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostMutationBody =
	BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost;
export type GetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostMutationError =
	HTTPValidationError;

/**
 * @summary Get Scheduled Flow Runs
 */
export const useGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost
			>
		>,
		TError,
		{
			name: string;
			data: BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof getScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost>
	>,
	TError,
	{
		name: string;
		data: BodyGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPost;
	},
	TContext
> => {
	const mutationOptions =
		getGetScheduledFlowRunsWorkPoolsNameGetScheduledFlowRunsPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Creates a new work pool queue. If a work pool queue with the same
name already exists, an error will be raised.
 * @summary Create Work Queue
 */
export type createWorkQueueWorkPoolsWorkPoolNameQueuesPostResponse = {
	data: WorkQueueResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateWorkQueueWorkPoolsWorkPoolNameQueuesPostUrl = (
	workPoolName: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/queues`;
};

export const createWorkQueueWorkPoolsWorkPoolNameQueuesPost = async (
	workPoolName: string,
	workQueueCreate: WorkQueueCreate,
	options?: RequestInit,
): Promise<createWorkQueueWorkPoolsWorkPoolNameQueuesPostResponse> => {
	const res = await fetch(
		getCreateWorkQueueWorkPoolsWorkPoolNameQueuesPostUrl(workPoolName),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(workQueueCreate),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createWorkQueueWorkPoolsWorkPoolNameQueuesPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createWorkQueueWorkPoolsWorkPoolNameQueuesPostResponse;
};

export const getCreateWorkQueueWorkPoolsWorkPoolNameQueuesPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof createWorkQueueWorkPoolsWorkPoolNameQueuesPost>
			>,
			TError,
			{ workPoolName: string; data: WorkQueueCreate },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<ReturnType<typeof createWorkQueueWorkPoolsWorkPoolNameQueuesPost>>,
		TError,
		{ workPoolName: string; data: WorkQueueCreate },
		TContext
	> => {
		const mutationKey = ["createWorkQueueWorkPoolsWorkPoolNameQueuesPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof createWorkQueueWorkPoolsWorkPoolNameQueuesPost>
			>,
			{ workPoolName: string; data: WorkQueueCreate }
		> = (props) => {
			const { workPoolName, data } = props ?? {};

			return createWorkQueueWorkPoolsWorkPoolNameQueuesPost(
				workPoolName,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type CreateWorkQueueWorkPoolsWorkPoolNameQueuesPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof createWorkQueueWorkPoolsWorkPoolNameQueuesPost>>
	>;
export type CreateWorkQueueWorkPoolsWorkPoolNameQueuesPostMutationBody =
	WorkQueueCreate;
export type CreateWorkQueueWorkPoolsWorkPoolNameQueuesPostMutationError =
	HTTPValidationError;

/**
 * @summary Create Work Queue
 */
export const useCreateWorkQueueWorkPoolsWorkPoolNameQueuesPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createWorkQueueWorkPoolsWorkPoolNameQueuesPost>>,
		TError,
		{ workPoolName: string; data: WorkQueueCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createWorkQueueWorkPoolsWorkPoolNameQueuesPost>>,
	TError,
	{ workPoolName: string; data: WorkQueueCreate },
	TContext
> => {
	const mutationOptions =
		getCreateWorkQueueWorkPoolsWorkPoolNameQueuesPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Read a work pool queue
 * @summary Read Work Queue
 */
export type readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponse = {
	data: WorkQueueResponse | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetUrl = (
	workPoolName: string,
	name: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/queues/${name}`;
};

export const readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet = async (
	workPoolName: string,
	name: string,
	options?: RequestInit,
): Promise<readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponse> => {
	const res = await fetch(
		getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetUrl(workPoolName, name),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkQueueWorkPoolsWorkPoolNameQueuesNameGetResponse;
};

export const getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetQueryKey = (
	workPoolName: string,
	name: string,
) => {
	return [
		`http://prefect.grose.click/api/work_pools/${workPoolName}/queues/${name}`,
	] as const;
};

export const getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetQueryOptions = <
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetQueryKey(
			workPoolName,
			name,
		);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>>
	> = ({ signal }) =>
		readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet(workPoolName, name, {
			signal,
			...fetchOptions,
		});

	return {
		queryKey,
		queryFn,
		enabled: !!(workPoolName && name),
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>>
	>;
export type ReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetQueryError =
	HTTPValidationError;

export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGet<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
					>,
					TError,
					Awaited<
						ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGet<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
					>,
					TError,
					Awaited<
						ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGet<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue
 */

export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGet<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetQueryOptions(
			workPoolName,
			name,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
		>,
		TError = HTTPValidationError,
	>(
		workPoolName: string,
		name: string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetQueryKey(
				workPoolName,
				name,
			);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
			>
		> = ({ signal }) =>
			readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet(workPoolName, name, {
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>>
	>;
export type ReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspenseQueryError =
	HTTPValidationError;

export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Work Queue
 */

export function useReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspense<
	TData = Awaited<
		ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
	>,
	TError = HTTPValidationError,
>(
	workPoolName: string,
	name: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readWorkQueueWorkPoolsWorkPoolNameQueuesNameGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadWorkQueueWorkPoolsWorkPoolNameQueuesNameGetSuspenseQueryOptions(
			workPoolName,
			name,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Update a work pool queue
 * @summary Update Work Queue
 */
export type updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getUpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchUrl = (
	workPoolName: string,
	name: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/queues/${name}`;
};

export const updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch = async (
	workPoolName: string,
	name: string,
	workQueueUpdate: WorkQueueUpdate,
	options?: RequestInit,
): Promise<updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchResponse> => {
	const res = await fetch(
		getUpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchUrl(
			workPoolName,
			name,
		),
		{
			...options,
			method: "PATCH",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(workQueueUpdate),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchResponse;
};

export const getUpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch>
			>,
			TError,
			{ workPoolName: string; name: string; data: WorkQueueUpdate },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch>
		>,
		TError,
		{ workPoolName: string; name: string; data: WorkQueueUpdate },
		TContext
	> => {
		const mutationKey = ["updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch>
			>,
			{ workPoolName: string; name: string; data: WorkQueueUpdate }
		> = (props) => {
			const { workPoolName, name, data } = props ?? {};

			return updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch(
				workPoolName,
				name,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type UpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch>
		>
	>;
export type UpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchMutationBody =
	WorkQueueUpdate;
export type UpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchMutationError =
	HTTPValidationError;

/**
 * @summary Update Work Queue
 */
export const useUpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch>
		>,
		TError,
		{ workPoolName: string; name: string; data: WorkQueueUpdate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof updateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatch>
	>,
	TError,
	{ workPoolName: string; name: string; data: WorkQueueUpdate },
	TContext
> => {
	const mutationOptions =
		getUpdateWorkQueueWorkPoolsWorkPoolNameQueuesNamePatchMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Delete a work pool queue
 * @summary Delete Work Queue
 */
export type deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteUrl = (
	workPoolName: string,
	name: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/queues/${name}`;
};

export const deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete = async (
	workPoolName: string,
	name: string,
	options?: RequestInit,
): Promise<deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteResponse> => {
	const res = await fetch(
		getDeleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteUrl(
			workPoolName,
			name,
		),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteResponse;
};

export const getDeleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete>
			>,
			TError,
			{ workPoolName: string; name: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete>
		>,
		TError,
		{ workPoolName: string; name: string },
		TContext
	> => {
		const mutationKey = [
			"deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete>
			>,
			{ workPoolName: string; name: string }
		> = (props) => {
			const { workPoolName, name } = props ?? {};

			return deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete(
				workPoolName,
				name,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DeleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete>
		>
	>;

export type DeleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Work Queue
 */
export const useDeleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete>
		>,
		TError,
		{ workPoolName: string; name: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof deleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDelete>
	>,
	TError,
	{ workPoolName: string; name: string },
	TContext
> => {
	const mutationOptions =
		getDeleteWorkQueueWorkPoolsWorkPoolNameQueuesNameDeleteMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Read all work pool queues
 * @summary Read Work Queues
 */
export type readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponse = {
	data: WorkQueueResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostUrl = (
	workPoolName: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/queues/filter`;
};

export const readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost = async (
	workPoolName: string,
	bodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost: BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost,
	options?: RequestInit,
): Promise<readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponse> => {
	const res = await fetch(
		getReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostUrl(workPoolName),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostResponse;
};

export const getReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost>
			>,
			TError,
			{
				workPoolName: string;
				data: BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost;
			},
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost>
		>,
		TError,
		{
			workPoolName: string;
			data: BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost;
		},
		TContext
	> => {
		const mutationKey = ["readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost>
			>,
			{
				workPoolName: string;
				data: BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost;
			}
		> = (props) => {
			const { workPoolName, data } = props ?? {};

			return readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost(
				workPoolName,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type ReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost>
		>
	>;
export type ReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostMutationBody =
	BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost;
export type ReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Work Queues
 */
export const useReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost>
		>,
		TError,
		{
			workPoolName: string;
			data: BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof readWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost>
	>,
	TError,
	{
		workPoolName: string;
		data: BodyReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPost;
	},
	TContext
> => {
	const mutationOptions =
		getReadWorkQueuesWorkPoolsWorkPoolNameQueuesFilterPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Worker Heartbeat
 */
export type workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostUrl = (
	workPoolName: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/workers/heartbeat`;
};

export const workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost = async (
	workPoolName: string,
	bodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost: BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost,
	options?: RequestInit,
): Promise<workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostResponse> => {
	const res = await fetch(
		getWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostUrl(
			workPoolName,
		),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostResponse;
};

export const getWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost
				>
			>,
			TError,
			{
				workPoolName: string;
				data: BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost;
			},
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost
			>
		>,
		TError,
		{
			workPoolName: string;
			data: BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost;
		},
		TContext
	> => {
		const mutationKey = [
			"workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost
				>
			>,
			{
				workPoolName: string;
				data: BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost;
			}
		> = (props) => {
			const { workPoolName, data } = props ?? {};

			return workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost(
				workPoolName,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type WorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost
			>
		>
	>;
export type WorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostMutationBody =
	BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost;
export type WorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostMutationError =
	HTTPValidationError;

/**
 * @summary Worker Heartbeat
 */
export const useWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost
			>
		>,
		TError,
		{
			workPoolName: string;
			data: BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof workerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost>
	>,
	TError,
	{
		workPoolName: string;
		data: BodyWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPost;
	},
	TContext
> => {
	const mutationOptions =
		getWorkerHeartbeatWorkPoolsWorkPoolNameWorkersHeartbeatPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Read all worker processes
 * @summary Read Workers
 */
export type readWorkersWorkPoolsWorkPoolNameWorkersFilterPostResponse = {
	data: WorkerResponse[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadWorkersWorkPoolsWorkPoolNameWorkersFilterPostUrl = (
	workPoolName: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/workers/filter`;
};

export const readWorkersWorkPoolsWorkPoolNameWorkersFilterPost = async (
	workPoolName: string,
	bodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost: BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost,
	options?: RequestInit,
): Promise<readWorkersWorkPoolsWorkPoolNameWorkersFilterPostResponse> => {
	const res = await fetch(
		getReadWorkersWorkPoolsWorkPoolNameWorkersFilterPostUrl(workPoolName),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readWorkersWorkPoolsWorkPoolNameWorkersFilterPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readWorkersWorkPoolsWorkPoolNameWorkersFilterPostResponse;
};

export const getReadWorkersWorkPoolsWorkPoolNameWorkersFilterPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof readWorkersWorkPoolsWorkPoolNameWorkersFilterPost>
			>,
			TError,
			{
				workPoolName: string;
				data: BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost;
			},
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof readWorkersWorkPoolsWorkPoolNameWorkersFilterPost>
		>,
		TError,
		{
			workPoolName: string;
			data: BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost;
		},
		TContext
	> => {
		const mutationKey = ["readWorkersWorkPoolsWorkPoolNameWorkersFilterPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof readWorkersWorkPoolsWorkPoolNameWorkersFilterPost>
			>,
			{
				workPoolName: string;
				data: BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost;
			}
		> = (props) => {
			const { workPoolName, data } = props ?? {};

			return readWorkersWorkPoolsWorkPoolNameWorkersFilterPost(
				workPoolName,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type ReadWorkersWorkPoolsWorkPoolNameWorkersFilterPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readWorkersWorkPoolsWorkPoolNameWorkersFilterPost>
		>
	>;
export type ReadWorkersWorkPoolsWorkPoolNameWorkersFilterPostMutationBody =
	BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost;
export type ReadWorkersWorkPoolsWorkPoolNameWorkersFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Workers
 */
export const useReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof readWorkersWorkPoolsWorkPoolNameWorkersFilterPost>
		>,
		TError,
		{
			workPoolName: string;
			data: BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readWorkersWorkPoolsWorkPoolNameWorkersFilterPost>>,
	TError,
	{
		workPoolName: string;
		data: BodyReadWorkersWorkPoolsWorkPoolNameWorkersFilterPost;
	},
	TContext
> => {
	const mutationOptions =
		getReadWorkersWorkPoolsWorkPoolNameWorkersFilterPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Delete a work pool's worker
 * @summary Delete Worker
 */
export type deleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteResponse = {
	data: void | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteUrl = (
	workPoolName: string,
	name: string,
) => {
	return `http://prefect.grose.click/api/work_pools/${workPoolName}/workers/${name}`;
};

export const deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete = async (
	workPoolName: string,
	name: string,
	options?: RequestInit,
): Promise<deleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteResponse> => {
	const res = await fetch(
		getDeleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteUrl(
			workPoolName,
			name,
		),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteResponse;
};

export const getDeleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete>
			>,
			TError,
			{ workPoolName: string; name: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete>
		>,
		TError,
		{ workPoolName: string; name: string },
		TContext
	> => {
		const mutationKey = ["deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete>
			>,
			{ workPoolName: string; name: string }
		> = (props) => {
			const { workPoolName, name } = props ?? {};

			return deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete(
				workPoolName,
				name,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DeleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteMutationResult =
	NonNullable<
		Awaited<
			ReturnType<typeof deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete>
		>
	>;

export type DeleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Worker
 */
export const useDeleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete>
		>,
		TError,
		{ workPoolName: string; name: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof deleteWorkerWorkPoolsWorkPoolNameWorkersNameDelete>
	>,
	TError,
	{ workPoolName: string; name: string },
	TContext
> => {
	const mutationOptions =
		getDeleteWorkerWorkPoolsWorkPoolNameWorkersNameDeleteMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
