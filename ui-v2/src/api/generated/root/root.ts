/**
 * Generated by orval v7.5.0 ðŸº
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type { HTTPValidationError } from "../../models";

/**
 * @summary Health Check
 */
export type healthCheckHealthGetResponse = {
	data: boolean;
	status: number;
	headers: Headers;
};

export const getHealthCheckHealthGetUrl = () => {
	return `http://prefect.grose.click/api/health`;
};

export const healthCheckHealthGet = async (
	options?: RequestInit,
): Promise<healthCheckHealthGetResponse> => {
	const res = await fetch(getHealthCheckHealthGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: healthCheckHealthGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as healthCheckHealthGetResponse;
};

export const getHealthCheckHealthGetQueryKey = () => {
	return [`http://prefect.grose.click/api/health`] as const;
};

export const getHealthCheckHealthGetQueryOptions = <
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof healthCheckHealthGet>>
	> = ({ signal }) => healthCheckHealthGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof healthCheckHealthGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckHealthGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof healthCheckHealthGet>>
>;
export type HealthCheckHealthGetQueryError = unknown;

export function useHealthCheckHealthGet<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options: {
	query: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof healthCheckHealthGet>>,
				TError,
				Awaited<ReturnType<typeof healthCheckHealthGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGet<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof healthCheckHealthGet>>,
				TError,
				Awaited<ReturnType<typeof healthCheckHealthGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGet<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGet<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getHealthCheckHealthGetQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getHealthCheckHealthGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getHealthCheckHealthGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof healthCheckHealthGet>>
	> = ({ signal }) => healthCheckHealthGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof healthCheckHealthGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HealthCheckHealthGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof healthCheckHealthGet>>
>;
export type HealthCheckHealthGetSuspenseQueryError = unknown;

export function useHealthCheckHealthGetSuspense<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options: {
	query: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGetSuspense<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHealthCheckHealthGetSuspense<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Health Check
 */

export function useHealthCheckHealthGetSuspense<
	TData = Awaited<ReturnType<typeof healthCheckHealthGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof healthCheckHealthGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getHealthCheckHealthGetSuspenseQueryOptions(options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Server Version
 */
export type serverVersionVersionGetResponse = {
	data: string;
	status: number;
	headers: Headers;
};

export const getServerVersionVersionGetUrl = () => {
	return `http://prefect.grose.click/api/version`;
};

export const serverVersionVersionGet = async (
	options?: RequestInit,
): Promise<serverVersionVersionGetResponse> => {
	const res = await fetch(getServerVersionVersionGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: serverVersionVersionGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as serverVersionVersionGetResponse;
};

export const getServerVersionVersionGetQueryKey = () => {
	return [`http://prefect.grose.click/api/version`] as const;
};

export const getServerVersionVersionGetQueryOptions = <
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getServerVersionVersionGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverVersionVersionGet>>
	> = ({ signal }) => serverVersionVersionGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof serverVersionVersionGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerVersionVersionGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverVersionVersionGet>>
>;
export type ServerVersionVersionGetQueryError = unknown;

export function useServerVersionVersionGet<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options: {
	query: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof serverVersionVersionGet>>,
				TError,
				Awaited<ReturnType<typeof serverVersionVersionGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerVersionVersionGet<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof serverVersionVersionGet>>,
				TError,
				Awaited<ReturnType<typeof serverVersionVersionGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerVersionVersionGet<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Server Version
 */

export function useServerVersionVersionGet<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getServerVersionVersionGetQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getServerVersionVersionGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getServerVersionVersionGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof serverVersionVersionGet>>
	> = ({ signal }) => serverVersionVersionGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof serverVersionVersionGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ServerVersionVersionGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof serverVersionVersionGet>>
>;
export type ServerVersionVersionGetSuspenseQueryError = unknown;

export function useServerVersionVersionGetSuspense<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options: {
	query: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerVersionVersionGetSuspense<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useServerVersionVersionGetSuspense<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Server Version
 */

export function useServerVersionVersionGetSuspense<
	TData = Awaited<ReturnType<typeof serverVersionVersionGet>>,
	TError = unknown,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof serverVersionVersionGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getServerVersionVersionGetSuspenseQueryOptions(options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * Say hello!
 * @summary Hello
 */
export type helloHelloGetResponse = {
	data: string | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getHelloHelloGetUrl = () => {
	return `http://prefect.grose.click/api/hello`;
};

export const helloHelloGet = async (
	options?: RequestInit,
): Promise<helloHelloGetResponse> => {
	const res = await fetch(getHelloHelloGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: helloHelloGetResponse["data"] = body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as helloHelloGetResponse;
};

export const getHelloHelloGetQueryKey = () => {
	return [`http://prefect.grose.click/api/hello`] as const;
};

export const getHelloHelloGetQueryOptions = <
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof helloHelloGet>>, TError, TData>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getHelloHelloGetQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof helloHelloGet>>> = ({
		signal,
	}) => helloHelloGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof helloHelloGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HelloHelloGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof helloHelloGet>>
>;
export type HelloHelloGetQueryError = HTTPValidationError;

export function useHelloHelloGet<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof helloHelloGet>>, TError, TData>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof helloHelloGet>>,
				TError,
				Awaited<ReturnType<typeof helloHelloGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHelloHelloGet<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof helloHelloGet>>, TError, TData>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof helloHelloGet>>,
				TError,
				Awaited<ReturnType<typeof helloHelloGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHelloHelloGet<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof helloHelloGet>>, TError, TData>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Hello
 */

export function useHelloHelloGet<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<Awaited<ReturnType<typeof helloHelloGet>>, TError, TData>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getHelloHelloGetQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getHelloHelloGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof helloHelloGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getHelloHelloGetQueryKey();

	const queryFn: QueryFunction<Awaited<ReturnType<typeof helloHelloGet>>> = ({
		signal,
	}) => helloHelloGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof helloHelloGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type HelloHelloGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof helloHelloGet>>
>;
export type HelloHelloGetSuspenseQueryError = HTTPValidationError;

export function useHelloHelloGetSuspense<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof helloHelloGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHelloHelloGetSuspense<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof helloHelloGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useHelloHelloGetSuspense<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof helloHelloGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Hello
 */

export function useHelloHelloGetSuspense<
	TData = Awaited<ReturnType<typeof helloHelloGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof helloHelloGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getHelloHelloGetSuspenseQueryOptions(options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Perform Readiness Check
 */
export type performReadinessCheckReadyGetResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getPerformReadinessCheckReadyGetUrl = () => {
	return `http://prefect.grose.click/api/ready`;
};

export const performReadinessCheckReadyGet = async (
	options?: RequestInit,
): Promise<performReadinessCheckReadyGetResponse> => {
	const res = await fetch(getPerformReadinessCheckReadyGetUrl(), {
		...options,
		method: "GET",
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: performReadinessCheckReadyGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as performReadinessCheckReadyGetResponse;
};

export const getPerformReadinessCheckReadyGetQueryKey = () => {
	return [`http://prefect.grose.click/api/ready`] as const;
};

export const getPerformReadinessCheckReadyGetQueryOptions = <
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getPerformReadinessCheckReadyGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof performReadinessCheckReadyGet>>
	> = ({ signal }) =>
		performReadinessCheckReadyGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PerformReadinessCheckReadyGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof performReadinessCheckReadyGet>>
>;
export type PerformReadinessCheckReadyGetQueryError = HTTPValidationError;

export function usePerformReadinessCheckReadyGet<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	> &
		Pick<
			DefinedInitialDataOptions<
				Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
				TError,
				Awaited<ReturnType<typeof performReadinessCheckReadyGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePerformReadinessCheckReadyGet<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	> &
		Pick<
			UndefinedInitialDataOptions<
				Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
				TError,
				Awaited<ReturnType<typeof performReadinessCheckReadyGet>>
			>,
			"initialData"
		>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePerformReadinessCheckReadyGet<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Perform Readiness Check
 */

export function usePerformReadinessCheckReadyGet<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions = getPerformReadinessCheckReadyGetQueryOptions(options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getPerformReadinessCheckReadyGetSuspenseQueryOptions = <
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ?? getPerformReadinessCheckReadyGetQueryKey();

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof performReadinessCheckReadyGet>>
	> = ({ signal }) =>
		performReadinessCheckReadyGet({ signal, ...fetchOptions });

	return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
		Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type PerformReadinessCheckReadyGetSuspenseQueryResult = NonNullable<
	Awaited<ReturnType<typeof performReadinessCheckReadyGet>>
>;
export type PerformReadinessCheckReadyGetSuspenseQueryError =
	HTTPValidationError;

export function usePerformReadinessCheckReadyGetSuspense<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options: {
	query: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePerformReadinessCheckReadyGetSuspense<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function usePerformReadinessCheckReadyGetSuspense<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Perform Readiness Check
 */

export function usePerformReadinessCheckReadyGetSuspense<
	TData = Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
	TError = HTTPValidationError,
>(options?: {
	query?: Partial<
		UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof performReadinessCheckReadyGet>>,
			TError,
			TData
		>
	>;
	fetch?: RequestInit;
}): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getPerformReadinessCheckReadyGetSuspenseQueryOptions(options);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}
