/**
 * Generated by orval v7.5.0 ðŸº
 * Do not edit manually.
 * Prefect Prefect REST API
 * OpenAPI spec version: 0.1.0
 */
import { useMutation, useQuery, useSuspenseQuery } from "@tanstack/react-query";
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult,
	UseSuspenseQueryOptions,
	UseSuspenseQueryResult,
} from "@tanstack/react-query";
import type {
	BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost,
	BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost,
	BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost,
	BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost,
	ConcurrencyLimit,
	ConcurrencyLimitCreate,
	HTTPValidationError,
	MinimalConcurrencyLimitResponse,
} from "../../models";

/**
 * @summary Create Concurrency Limit
 */
export type createConcurrencyLimitConcurrencyLimitsPostResponse = {
	data: ConcurrencyLimit | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getCreateConcurrencyLimitConcurrencyLimitsPostUrl = () => {
	return `http://prefect.grose.click/api/concurrency_limits/`;
};

export const createConcurrencyLimitConcurrencyLimitsPost = async (
	concurrencyLimitCreate: ConcurrencyLimitCreate,
	options?: RequestInit,
): Promise<createConcurrencyLimitConcurrencyLimitsPostResponse> => {
	const res = await fetch(getCreateConcurrencyLimitConcurrencyLimitsPostUrl(), {
		...options,
		method: "POST",
		headers: { "Content-Type": "application/json", ...options?.headers },
		body: JSON.stringify(concurrencyLimitCreate),
	});

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: createConcurrencyLimitConcurrencyLimitsPostResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as createConcurrencyLimitConcurrencyLimitsPostResponse;
};

export const getCreateConcurrencyLimitConcurrencyLimitsPostMutationOptions = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createConcurrencyLimitConcurrencyLimitsPost>>,
		TError,
		{ data: ConcurrencyLimitCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationOptions<
	Awaited<ReturnType<typeof createConcurrencyLimitConcurrencyLimitsPost>>,
	TError,
	{ data: ConcurrencyLimitCreate },
	TContext
> => {
	const mutationKey = ["createConcurrencyLimitConcurrencyLimitsPost"];
	const { mutation: mutationOptions, fetch: fetchOptions } = options
		? options.mutation &&
			"mutationKey" in options.mutation &&
			options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey }, fetch: undefined };

	const mutationFn: MutationFunction<
		Awaited<ReturnType<typeof createConcurrencyLimitConcurrencyLimitsPost>>,
		{ data: ConcurrencyLimitCreate }
	> = (props) => {
		const { data } = props ?? {};

		return createConcurrencyLimitConcurrencyLimitsPost(data, fetchOptions);
	};

	return { mutationFn, ...mutationOptions };
};

export type CreateConcurrencyLimitConcurrencyLimitsPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof createConcurrencyLimitConcurrencyLimitsPost>>
	>;
export type CreateConcurrencyLimitConcurrencyLimitsPostMutationBody =
	ConcurrencyLimitCreate;
export type CreateConcurrencyLimitConcurrencyLimitsPostMutationError =
	HTTPValidationError;

/**
 * @summary Create Concurrency Limit
 */
export const useCreateConcurrencyLimitConcurrencyLimitsPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof createConcurrencyLimitConcurrencyLimitsPost>>,
		TError,
		{ data: ConcurrencyLimitCreate },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof createConcurrencyLimitConcurrencyLimitsPost>>,
	TError,
	{ data: ConcurrencyLimitCreate },
	TContext
> => {
	const mutationOptions =
		getCreateConcurrencyLimitConcurrencyLimitsPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a concurrency limit by id.

The `active slots` field contains a list of TaskRun IDs currently using a
concurrency slot for the specified tag.
 * @summary Read Concurrency Limit
 */
export type readConcurrencyLimitConcurrencyLimitsIdGetResponse = {
	data: ConcurrencyLimit | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadConcurrencyLimitConcurrencyLimitsIdGetUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/concurrency_limits/${id}`;
};

export const readConcurrencyLimitConcurrencyLimitsIdGet = async (
	id: string,
	options?: RequestInit,
): Promise<readConcurrencyLimitConcurrencyLimitsIdGetResponse> => {
	const res = await fetch(
		getReadConcurrencyLimitConcurrencyLimitsIdGetUrl(id),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readConcurrencyLimitConcurrencyLimitsIdGetResponse["data"] = body
		? JSON.parse(body)
		: {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readConcurrencyLimitConcurrencyLimitsIdGetResponse;
};

export const getReadConcurrencyLimitConcurrencyLimitsIdGetQueryKey = (
	id: string,
) => {
	return [`http://prefect.grose.click/api/concurrency_limits/${id}`] as const;
};

export const getReadConcurrencyLimitConcurrencyLimitsIdGetQueryOptions = <
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
) => {
	const { query: queryOptions, fetch: fetchOptions } = options ?? {};

	const queryKey =
		queryOptions?.queryKey ??
		getReadConcurrencyLimitConcurrencyLimitsIdGetQueryKey(id);

	const queryFn: QueryFunction<
		Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>
	> = ({ signal }) =>
		readConcurrencyLimitConcurrencyLimitsIdGet(id, { signal, ...fetchOptions });

	return {
		queryKey,
		queryFn,
		enabled: !!id,
		...queryOptions,
	} as UseQueryOptions<
		Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type ReadConcurrencyLimitConcurrencyLimitsIdGetQueryResult = NonNullable<
	Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>
>;
export type ReadConcurrencyLimitConcurrencyLimitsIdGetQueryError =
	HTTPValidationError;

export function useReadConcurrencyLimitConcurrencyLimitsIdGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
					>,
					TError,
					Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitConcurrencyLimitsIdGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
					>,
					TError,
					Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitConcurrencyLimitsIdGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Concurrency Limit
 */

export function useReadConcurrencyLimitConcurrencyLimitsIdGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadConcurrencyLimitConcurrencyLimitsIdGetQueryOptions(id, options);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadConcurrencyLimitConcurrencyLimitsIdGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
		>,
		TError = HTTPValidationError,
	>(
		id: string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadConcurrencyLimitConcurrencyLimitsIdGetQueryKey(id);

		const queryFn: QueryFunction<
			Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>
		> = ({ signal }) =>
			readConcurrencyLimitConcurrencyLimitsIdGet(id, {
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadConcurrencyLimitConcurrencyLimitsIdGetSuspenseQueryResult =
	NonNullable<
		Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>
	>;
export type ReadConcurrencyLimitConcurrencyLimitsIdGetSuspenseQueryError =
	HTTPValidationError;

export function useReadConcurrencyLimitConcurrencyLimitsIdGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitConcurrencyLimitsIdGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitConcurrencyLimitsIdGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Concurrency Limit
 */

export function useReadConcurrencyLimitConcurrencyLimitsIdGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>
	>,
	TError = HTTPValidationError,
>(
	id: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<ReturnType<typeof readConcurrencyLimitConcurrencyLimitsIdGet>>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadConcurrencyLimitConcurrencyLimitsIdGetSuspenseQueryOptions(
			id,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Delete Concurrency Limit
 */
export type deleteConcurrencyLimitConcurrencyLimitsIdDeleteResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteConcurrencyLimitConcurrencyLimitsIdDeleteUrl = (
	id: string,
) => {
	return `http://prefect.grose.click/api/concurrency_limits/${id}`;
};

export const deleteConcurrencyLimitConcurrencyLimitsIdDelete = async (
	id: string,
	options?: RequestInit,
): Promise<deleteConcurrencyLimitConcurrencyLimitsIdDeleteResponse> => {
	const res = await fetch(
		getDeleteConcurrencyLimitConcurrencyLimitsIdDeleteUrl(id),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteConcurrencyLimitConcurrencyLimitsIdDeleteResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteConcurrencyLimitConcurrencyLimitsIdDeleteResponse;
};

export const getDeleteConcurrencyLimitConcurrencyLimitsIdDeleteMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof deleteConcurrencyLimitConcurrencyLimitsIdDelete>
			>,
			TError,
			{ id: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<ReturnType<typeof deleteConcurrencyLimitConcurrencyLimitsIdDelete>>,
		TError,
		{ id: string },
		TContext
	> => {
		const mutationKey = ["deleteConcurrencyLimitConcurrencyLimitsIdDelete"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof deleteConcurrencyLimitConcurrencyLimitsIdDelete>
			>,
			{ id: string }
		> = (props) => {
			const { id } = props ?? {};

			return deleteConcurrencyLimitConcurrencyLimitsIdDelete(id, fetchOptions);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DeleteConcurrencyLimitConcurrencyLimitsIdDeleteMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof deleteConcurrencyLimitConcurrencyLimitsIdDelete>>
	>;

export type DeleteConcurrencyLimitConcurrencyLimitsIdDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Concurrency Limit
 */
export const useDeleteConcurrencyLimitConcurrencyLimitsIdDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<typeof deleteConcurrencyLimitConcurrencyLimitsIdDelete>>,
		TError,
		{ id: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof deleteConcurrencyLimitConcurrencyLimitsIdDelete>>,
	TError,
	{ id: string },
	TContext
> => {
	const mutationOptions =
		getDeleteConcurrencyLimitConcurrencyLimitsIdDeleteMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * Get a concurrency limit by tag.

The `active slots` field contains a list of TaskRun IDs currently using a
concurrency slot for the specified tag.
 * @summary Read Concurrency Limit By Tag
 */
export type readConcurrencyLimitByTagConcurrencyLimitsTagTagGetResponse = {
	data: ConcurrencyLimit | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetUrl = (
	tag: string,
) => {
	return `http://prefect.grose.click/api/concurrency_limits/tag/${tag}`;
};

export const readConcurrencyLimitByTagConcurrencyLimitsTagTagGet = async (
	tag: string,
	options?: RequestInit,
): Promise<readConcurrencyLimitByTagConcurrencyLimitsTagTagGetResponse> => {
	const res = await fetch(
		getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetUrl(tag),
		{
			...options,
			method: "GET",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readConcurrencyLimitByTagConcurrencyLimitsTagTagGetResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readConcurrencyLimitByTagConcurrencyLimitsTagTagGetResponse;
};

export const getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetQueryKey = (
	tag: string,
) => {
	return [
		`http://prefect.grose.click/api/concurrency_limits/tag/${tag}`,
	] as const;
};

export const getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
		>,
		TError = HTTPValidationError,
	>(
		tag: string,
		options?: {
			query?: Partial<
				UseQueryOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetQueryKey(tag);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
			>
		> = ({ signal }) =>
			readConcurrencyLimitByTagConcurrencyLimitsTagTagGet(tag, {
				signal,
				...fetchOptions,
			});

		return {
			queryKey,
			queryFn,
			enabled: !!tag,
			...queryOptions,
		} as UseQueryOptions<
			Awaited<
				ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetQueryResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
		>
	>;
export type ReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetQueryError =
	HTTPValidationError;

export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options: {
		query: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): DefinedUseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet
						>
					>,
					TError,
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet
						>
					>
				>,
				"initialData"
			>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Concurrency Limit By Tag
 */

export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGet<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options?: {
		query?: Partial<
			UseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetQueryOptions(
			tag,
			options,
		);

	const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};

	query.queryKey = queryOptions.queryKey;

	return query;
}

export const getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspenseQueryOptions =
	<
		TData = Awaited<
			ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
		>,
		TError = HTTPValidationError,
	>(
		tag: string,
		options?: {
			query?: Partial<
				UseSuspenseQueryOptions<
					Awaited<
						ReturnType<
							typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet
						>
					>,
					TError,
					TData
				>
			>;
			fetch?: RequestInit;
		},
	) => {
		const { query: queryOptions, fetch: fetchOptions } = options ?? {};

		const queryKey =
			queryOptions?.queryKey ??
			getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetQueryKey(tag);

		const queryFn: QueryFunction<
			Awaited<
				ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
			>
		> = ({ signal }) =>
			readConcurrencyLimitByTagConcurrencyLimitsTagTagGet(tag, {
				signal,
				...fetchOptions,
			});

		return { queryKey, queryFn, ...queryOptions } as UseSuspenseQueryOptions<
			Awaited<
				ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
			>,
			TError,
			TData
		> & { queryKey: DataTag<QueryKey, TData, TError> };
	};

export type ReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspenseQueryResult =
	NonNullable<
		Awaited<
			ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
		>
	>;
export type ReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspenseQueryError =
	HTTPValidationError;

export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options: {
		query: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
};
/**
 * @summary Read Concurrency Limit By Tag
 */

export function useReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspense<
	TData = Awaited<
		ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
	>,
	TError = HTTPValidationError,
>(
	tag: string,
	options?: {
		query?: Partial<
			UseSuspenseQueryOptions<
				Awaited<
					ReturnType<typeof readConcurrencyLimitByTagConcurrencyLimitsTagTagGet>
				>,
				TError,
				TData
			>
		>;
		fetch?: RequestInit;
	},
): UseSuspenseQueryResult<TData, TError> & {
	queryKey: DataTag<QueryKey, TData, TError>;
} {
	const queryOptions =
		getReadConcurrencyLimitByTagConcurrencyLimitsTagTagGetSuspenseQueryOptions(
			tag,
			options,
		);

	const query = useSuspenseQuery(queryOptions) as UseSuspenseQueryResult<
		TData,
		TError
	> & { queryKey: DataTag<QueryKey, TData, TError> };

	query.queryKey = queryOptions.queryKey;

	return query;
}

/**
 * @summary Delete Concurrency Limit By Tag
 */
export type deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteResponse = {
	data: HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getDeleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteUrl = (
	tag: string,
) => {
	return `http://prefect.grose.click/api/concurrency_limits/tag/${tag}`;
};

export const deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete = async (
	tag: string,
	options?: RequestInit,
): Promise<deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteResponse> => {
	const res = await fetch(
		getDeleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteUrl(tag),
		{
			...options,
			method: "DELETE",
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteResponse;
};

export const getDeleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete
				>
			>,
			TError,
			{ tag: string },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete
			>
		>,
		TError,
		{ tag: string },
		TContext
	> => {
		const mutationKey = [
			"deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete
				>
			>,
			{ tag: string }
		> = (props) => {
			const { tag } = props ?? {};

			return deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete(
				tag,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DeleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete
			>
		>
	>;

export type DeleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteMutationError =
	HTTPValidationError;

/**
 * @summary Delete Concurrency Limit By Tag
 */
export const useDeleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete
			>
		>,
		TError,
		{ tag: string },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<typeof deleteConcurrencyLimitByTagConcurrencyLimitsTagTagDelete>
	>,
	TError,
	{ tag: string },
	TContext
> => {
	const mutationOptions =
		getDeleteConcurrencyLimitByTagConcurrencyLimitsTagTagDeleteMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * Query for concurrency limits.

For each concurrency limit the `active slots` field contains a list of TaskRun IDs
currently using a concurrency slot for the specified tag.
 * @summary Read Concurrency Limits
 */
export type readConcurrencyLimitsConcurrencyLimitsFilterPostResponse = {
	data: ConcurrencyLimit[] | HTTPValidationError;
	status: number;
	headers: Headers;
};

export const getReadConcurrencyLimitsConcurrencyLimitsFilterPostUrl = () => {
	return `http://prefect.grose.click/api/concurrency_limits/filter`;
};

export const readConcurrencyLimitsConcurrencyLimitsFilterPost = async (
	bodyReadConcurrencyLimitsConcurrencyLimitsFilterPost: BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost,
	options?: RequestInit,
): Promise<readConcurrencyLimitsConcurrencyLimitsFilterPostResponse> => {
	const res = await fetch(
		getReadConcurrencyLimitsConcurrencyLimitsFilterPostUrl(),
		{
			...options,
			method: "POST",
			headers: { "Content-Type": "application/json", ...options?.headers },
			body: JSON.stringify(
				bodyReadConcurrencyLimitsConcurrencyLimitsFilterPost,
			),
		},
	);

	const body = [204, 205, 304].includes(res.status) ? null : await res.text();
	const data: readConcurrencyLimitsConcurrencyLimitsFilterPostResponse["data"] =
		body ? JSON.parse(body) : {};

	return {
		data,
		status: res.status,
		headers: res.headers,
	} as readConcurrencyLimitsConcurrencyLimitsFilterPostResponse;
};

export const getReadConcurrencyLimitsConcurrencyLimitsFilterPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<typeof readConcurrencyLimitsConcurrencyLimitsFilterPost>
			>,
			TError,
			{ data: BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<typeof readConcurrencyLimitsConcurrencyLimitsFilterPost>
		>,
		TError,
		{ data: BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost },
		TContext
	> => {
		const mutationKey = ["readConcurrencyLimitsConcurrencyLimitsFilterPost"];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<typeof readConcurrencyLimitsConcurrencyLimitsFilterPost>
			>,
			{ data: BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost }
		> = (props) => {
			const { data } = props ?? {};

			return readConcurrencyLimitsConcurrencyLimitsFilterPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type ReadConcurrencyLimitsConcurrencyLimitsFilterPostMutationResult =
	NonNullable<
		Awaited<ReturnType<typeof readConcurrencyLimitsConcurrencyLimitsFilterPost>>
	>;
export type ReadConcurrencyLimitsConcurrencyLimitsFilterPostMutationBody =
	BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost;
export type ReadConcurrencyLimitsConcurrencyLimitsFilterPostMutationError =
	HTTPValidationError;

/**
 * @summary Read Concurrency Limits
 */
export const useReadConcurrencyLimitsConcurrencyLimitsFilterPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<typeof readConcurrencyLimitsConcurrencyLimitsFilterPost>
		>,
		TError,
		{ data: BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<ReturnType<typeof readConcurrencyLimitsConcurrencyLimitsFilterPost>>,
	TError,
	{ data: BodyReadConcurrencyLimitsConcurrencyLimitsFilterPost },
	TContext
> => {
	const mutationOptions =
		getReadConcurrencyLimitsConcurrencyLimitsFilterPostMutationOptions(options);

	return useMutation(mutationOptions);
};
/**
 * @summary Reset Concurrency Limit By Tag
 */
export type resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostResponse =
	{
		data: HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostUrl =
	(tag: string) => {
		return `http://prefect.grose.click/api/concurrency_limits/tag/${tag}/reset`;
	};

export const resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost =
	async (
		tag: string,
		bodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost: BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost,
		options?: RequestInit,
	): Promise<resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostResponse> => {
		const res = await fetch(
			getResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostUrl(tag),
			{
				...options,
				method: "POST",
				headers: { "Content-Type": "application/json", ...options?.headers },
				body: JSON.stringify(
					bodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost,
				),
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostResponse;
	};

export const getResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost
				>
			>,
			TError,
			{
				tag: string;
				data: BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost;
			},
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost
			>
		>,
		TError,
		{
			tag: string;
			data: BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost;
		},
		TContext
	> => {
		const mutationKey = [
			"resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost
				>
			>,
			{
				tag: string;
				data: BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost;
			}
		> = (props) => {
			const { tag, data } = props ?? {};

			return resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost(
				tag,
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type ResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost
			>
		>
	>;
export type ResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostMutationBody =
	BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost;
export type ResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostMutationError =
	HTTPValidationError;

/**
 * @summary Reset Concurrency Limit By Tag
 */
export const useResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost
			>
		>,
		TError,
		{
			tag: string;
			data: BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost;
		},
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<
			typeof resetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost
		>
	>,
	TError,
	{
		tag: string;
		data: BodyResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPost;
	},
	TContext
> => {
	const mutationOptions =
		getResetConcurrencyLimitByTagConcurrencyLimitsTagTagResetPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Increment Concurrency Limits V1
 */
export type incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostResponse =
	{
		data: MinimalConcurrencyLimitResponse[] | HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostUrl =
	() => {
		return `http://prefect.grose.click/api/concurrency_limits/increment`;
	};

export const incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost =
	async (
		bodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost: BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost,
		options?: RequestInit,
	): Promise<incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostResponse> => {
		const res = await fetch(
			getIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostUrl(),
			{
				...options,
				method: "POST",
				headers: { "Content-Type": "application/json", ...options?.headers },
				body: JSON.stringify(
					bodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost,
				),
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostResponse;
	};

export const getIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost
				>
			>,
			TError,
			{ data: BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost
			>
		>,
		TError,
		{ data: BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost },
		TContext
	> => {
		const mutationKey = [
			"incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost
				>
			>,
			{ data: BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost }
		> = (props) => {
			const { data } = props ?? {};

			return incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type IncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost
			>
		>
	>;
export type IncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostMutationBody =
	BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost;
export type IncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostMutationError =
	HTTPValidationError;

/**
 * @summary Increment Concurrency Limits V1
 */
export const useIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost
			>
		>,
		TError,
		{ data: BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<
			typeof incrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost
		>
	>,
	TError,
	{ data: BodyIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPost },
	TContext
> => {
	const mutationOptions =
		getIncrementConcurrencyLimitsV1ConcurrencyLimitsIncrementPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
/**
 * @summary Decrement Concurrency Limits V1
 */
export type decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostResponse =
	{
		data: HTTPValidationError;
		status: number;
		headers: Headers;
	};

export const getDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostUrl =
	() => {
		return `http://prefect.grose.click/api/concurrency_limits/decrement`;
	};

export const decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost =
	async (
		bodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost: BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost,
		options?: RequestInit,
	): Promise<decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostResponse> => {
		const res = await fetch(
			getDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostUrl(),
			{
				...options,
				method: "POST",
				headers: { "Content-Type": "application/json", ...options?.headers },
				body: JSON.stringify(
					bodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost,
				),
			},
		);

		const body = [204, 205, 304].includes(res.status) ? null : await res.text();
		const data: decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostResponse["data"] =
			body ? JSON.parse(body) : {};

		return {
			data,
			status: res.status,
			headers: res.headers,
		} as decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostResponse;
	};

export const getDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostMutationOptions =
	<TError = HTTPValidationError, TContext = unknown>(options?: {
		mutation?: UseMutationOptions<
			Awaited<
				ReturnType<
					typeof decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost
				>
			>,
			TError,
			{ data: BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost },
			TContext
		>;
		fetch?: RequestInit;
	}): UseMutationOptions<
		Awaited<
			ReturnType<
				typeof decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost
			>
		>,
		TError,
		{ data: BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost },
		TContext
	> => {
		const mutationKey = [
			"decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost",
		];
		const { mutation: mutationOptions, fetch: fetchOptions } = options
			? options.mutation &&
				"mutationKey" in options.mutation &&
				options.mutation.mutationKey
				? options
				: { ...options, mutation: { ...options.mutation, mutationKey } }
			: { mutation: { mutationKey }, fetch: undefined };

		const mutationFn: MutationFunction<
			Awaited<
				ReturnType<
					typeof decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost
				>
			>,
			{ data: BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost }
		> = (props) => {
			const { data } = props ?? {};

			return decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost(
				data,
				fetchOptions,
			);
		};

		return { mutationFn, ...mutationOptions };
	};

export type DecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostMutationResult =
	NonNullable<
		Awaited<
			ReturnType<
				typeof decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost
			>
		>
	>;
export type DecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostMutationBody =
	BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost;
export type DecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostMutationError =
	HTTPValidationError;

/**
 * @summary Decrement Concurrency Limits V1
 */
export const useDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost = <
	TError = HTTPValidationError,
	TContext = unknown,
>(options?: {
	mutation?: UseMutationOptions<
		Awaited<
			ReturnType<
				typeof decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost
			>
		>,
		TError,
		{ data: BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost },
		TContext
	>;
	fetch?: RequestInit;
}): UseMutationResult<
	Awaited<
		ReturnType<
			typeof decrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost
		>
	>,
	TError,
	{ data: BodyDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPost },
	TContext
> => {
	const mutationOptions =
		getDecrementConcurrencyLimitsV1ConcurrencyLimitsDecrementPostMutationOptions(
			options,
		);

	return useMutation(mutationOptions);
};
