---
title: Create tasks
description: Learn the basics of writing tasks.
---

A Prefect task is a Python function decorated with @task that represents a discrete unit of work in a 
Prefect workflow. Tasks can:

- Take inputs, perform work, and return outputs
- Encapsulate workflow logic into reusable units across flows and subflows
- Receive metadata about upstream task dependencies and their state before running
- Use automatic [logging](/3.0rc/develop/observe-workflows/logging/) to capture runtime details, tags, 
and final state
- Execute concurrently and cache return values
- Be defined in the same file as the flow or imported from modules
- Be called from flows, subflows, or other tasks (Prefect 2.18+)

Flows and tasks share some common features:

- They can be defined using their respective decorator, which accepts configuration settings 
(see all [task settings](/3.0rc/develop/write-tasks/#task-arguments) and 
[flow settings](/3.0rc/develop/write-workflows/#flow-settings))
- They can have a name, description, and tags for organization and bookkeeping
- They provide functionality for retries, timeouts, and other hooks to handle failure and completion events

## Example task

Here's an example of what it looks like to move a request from a flow into a task:

```python hl_lines="2 5-9 15" title="repo_info.py"
import httpx
from prefect import flow, task
from typing import Optional


@task
def get_url(url: str, params: Optional[dict[str, any]] = None):
    response = httpx.get(url, params=params)
    response.raise_for_status()
    return response.json()


@flow(retries=3, retry_delay_seconds=5, log_prints=True)
def get_repo_info(repo_name: str = "PrefectHQ/prefect"):
    url = f"https://api.github.com/repos/{repo_name}"
    repo_stats = get_url(url)
    print(f"{repo_name} repository statistics ü§ì:")
    print(f"Stars üå† : {repo_stats['stargazers_count']}")
    print(f"Forks üç¥ : {repo_stats['forks_count']}")

if __name__ == "__main__":
    get_repo_info()
```

Running that flow in the terminal results in something like this:

```bash
09:55:55.412 | INFO    | prefect.engine - Created flow run 'great-ammonite' for flow 'get-repo-info'
09:55:55.499 | INFO    | Flow run 'great-ammonite' - Created task run 'get_url-0' for task 'get_url'
09:55:55.500 | INFO    | Flow run 'great-ammonite' - Executing 'get_url-0' immediately...
09:55:55.825 | INFO    | Task run 'get_url-0' - Finished in state Completed()
09:55:55.827 | INFO    | Flow run 'great-ammonite' - PrefectHQ/prefect repository statistics ü§ì:
09:55:55.827 | INFO    | Flow run 'great-ammonite' - Stars üå† : 12157
09:55:55.827 | INFO    | Flow run 'great-ammonite' - Forks üç¥ : 1251
09:55:55.849 | INFO    | Flow run 'great-ammonite' - Finished in state Completed('All states completed.')
```

This task run is tracked in the UI as well.

## Concurrency

Tasks enable concurrency, allowing you to execute multiple tasks asynchronously.
This concurrency greatly enhances the efficiency and performance of your workflows.

Expand the script to calculate the average open issues per user by making more requests:

```python hl_lines="14-24 30-31 35" title="repo_info.py"
import httpx
from datetime import timedelta
from prefect import flow, task
from prefect.tasks import task_input_hash
from typing import Optional


@task(cache_key_fn=task_input_hash, cache_expiration=timedelta(hours=1))
def get_url(url: str, params: Optional[dict[str, any]] = None):
    response = httpx.get(url, params=params)
    response.raise_for_status()
    return response.json()


def get_open_issues(repo_name: str, open_issues_count: int, per_page: int = 100):
    issues = []
    pages = range(1, -(open_issues_count // -per_page) + 1)
    for page in pages:
        issues.append(
            get_url(
                f"https://api.github.com/repos/{repo_name}/issues",
                params={"page": page, "per_page": per_page, "state": "open"},
            )
        )
    return [i for p in issues for i in p]


@flow(retries=3, retry_delay_seconds=5, log_prints=True)
def get_repo_info(repo_name: str = "PrefectHQ/prefect"):
    repo_stats = get_url(f"https://api.github.com/repos/{repo_name}")
    issues = get_open_issues(repo_name, repo_stats["open_issues_count"])
    issues_per_user = len(issues) / len(set([i["user"]["id"] for i in issues]))
    print(f"{repo_name} repository statistics ü§ì:")
    print(f"Stars üå† : {repo_stats['stargazers_count']}")
    print(f"Forks üç¥ : {repo_stats['forks_count']}")
    print(f"Average open issues per user üíå : {issues_per_user:.2f}")


if __name__ == "__main__":
    get_repo_info()

```

Now you're fetching the data you need, but the requests happen sequentially.
Tasks expose a [`submit`](/3.0rc/api-ref/prefect/tasks/#prefect.tasks.Task.submit) method that changes 
the execution from sequential to concurrent.
In this example, you also need to use the 
[`result`](/3.0rc/api-ref/prefect/futures/#prefect.futures.PrefectFuture.result) 
method to unpack a list of return values:

```python hl_lines="6 11"
def get_open_issues(repo_name: str, open_issues_count: int, per_page: int = 100):
    issues = []
    pages = range(1, -(open_issues_count // -per_page) + 1)
    for page in pages:
        issues.append(
            get_url.submit(
                f"https://api.github.com/repos/{repo_name}/issues",
                params={"page": page, "per_page": per_page, "state": "open"},
            )
        )
    return [i for p in issues for i in p.result()]
```

The logs show that each task is running concurrently:


```bash
12:45:28.241 | INFO    | prefect.engine - Created flow run 'intrepid-coua' for flow 'get-repo-info'
12:45:28.311 | INFO    | Flow run 'intrepid-coua' - Created task run 'get_url-0' for task 'get_url'
12:45:28.312 | INFO    | Flow run 'intrepid-coua' - Executing 'get_url-0' immediately...
12:45:28.543 | INFO    | Task run 'get_url-0' - Finished in state Completed()
12:45:28.583 | INFO    | Flow run 'intrepid-coua' - Created task run 'get_url-1' for task 'get_url'
12:45:28.584 | INFO    | Flow run 'intrepid-coua' - Submitted task run 'get_url-1' for execution.
12:45:28.594 | INFO    | Flow run 'intrepid-coua' - Created task run 'get_url-2' for task 'get_url'
12:45:28.594 | INFO    | Flow run 'intrepid-coua' - Submitted task run 'get_url-2' for execution.
12:45:28.609 | INFO    | Flow run 'intrepid-coua' - Created task run 'get_url-4' for task 'get_url'
12:45:28.610 | INFO    | Flow run 'intrepid-coua' - Submitted task run 'get_url-4' for execution.
12:45:28.624 | INFO    | Flow run 'intrepid-coua' - Created task run 'get_url-5' for task 'get_url'
12:45:28.625 | INFO    | Flow run 'intrepid-coua' - Submitted task run 'get_url-5' for execution.
12:45:28.640 | INFO    | Flow run 'intrepid-coua' - Created task run 'get_url-6' for task 'get_url'
12:45:28.641 | INFO    | Flow run 'intrepid-coua' - Submitted task run 'get_url-6' for execution.
12:45:28.708 | INFO    | Flow run 'intrepid-coua' - Created task run 'get_url-3' for task 'get_url'
12:45:28.708 | INFO    | Flow run 'intrepid-coua' - Submitted task run 'get_url-3' for execution.
12:45:29.096 | INFO    | Task run 'get_url-6' - Finished in state Completed()
12:45:29.565 | INFO    | Task run 'get_url-2' - Finished in state Completed()
12:45:29.721 | INFO    | Task run 'get_url-5' - Finished in state Completed()
12:45:29.749 | INFO    | Task run 'get_url-4' - Finished in state Completed()
12:45:29.801 | INFO    | Task run 'get_url-3' - Finished in state Completed()
12:45:29.817 | INFO    | Task run 'get_url-1' - Finished in state Completed()
12:45:29.820 | INFO    | Flow run 'intrepid-coua' - PrefectHQ/prefect repository statistics ü§ì:
12:45:29.820 | INFO    | Flow run 'intrepid-coua' - Stars üå† : 12159
12:45:29.821 | INFO    | Flow run 'intrepid-coua' - Forks üç¥ : 1251
Average open issues per user üíå : 2.27
12:45:29.838 | INFO    | Flow run 'intrepid-coua' - Finished in state Completed('All states completed.')
```

**Call a task from a flow**

Use the `@task` decorator to designate a function as a task. Calling the task creates a new task run:

```python hl_lines="3-5"
from prefect import flow, task

@task
def my_task():
    print("Hello, I'm a task")

@flow
def my_flow():
    my_task()
```

**Call a task from another task**

As of `prefect 2.18.x`, you can call a task from within another task:

```python
from prefect import task

@task
def my_task():
    print("Hello, I'm a task")

@task(log_prints=True)
def my_parent_task():
    my_task()
```

Tasks are uniquely identified by a task key, which is a hash composed of the task name, the fully-qualified 
name of the function, and any tags. If the task does not have a name specified, the name is derived from the 
task function.

<Note>
**How big should a task be?**

Prefect encourages "small tasks." Each one should represent a single logical step of your workflow. 
This allows Prefect to better contain task failures.

There's nothing stopping you from putting all of your code in a single task. However, if any line of 
code fails, the entire task fails and must be retried from the beginning. 
Avoid this by splitting the code into multiple dependent tasks.
</Note>

## Task arguments

Tasks allow for customization through optional arguments:

| Argument              | Description                                                                                                                                                                                                             |
| --------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `name`                | An optional name for the task. If not provided, the name is inferred from the function name.                                                                                                                       |
| `description`         | An optional string description for the task. If not provided, the description is pulled from the docstring for the decorated function.                                                                             |
| `tags`                | An optional set of tags associated with runs of this task. These tags are combined with any tags defined by a `prefect.tags` context at task runtime.                                                             |
| `cache_key_fn`        | An optional callable that, given the task run context and call parameters, generates a string key. If the key matches a previous completed state, that state result is restored instead of running the task again. |
| `cache_expiration`    | An optional amount of time indicating how long cached states for this task are restorable; if not provided, cached states will never expire.                                                                      |
| `retries`             | An optional number of times to retry on task run failure.                                                                                                                                                               |
| `retry_delay_seconds` | An optional number of seconds to wait before retrying the task after failure. This is only applicable if `retries` is nonzero.                                                                                          |
| `log_prints`|An optional boolean indicating whether to log print statements. |
| `persist_result` | An optional boolean indicating whether to persist the result of the task run to storage. |

See all possible parameters in the [Python SDK API docs](/3.0rc/api-ref/prefect/tasks/#prefect.tasks.task).

For example, you can provide a `name` value for the task. Here's an example of the optional `description` argument 
as well:

```python hl_lines="1"
@task(name="hello-task", 
      description="This task says hello.")
def my_task():
    print("Hello, I'm a task")
```

You can distinguish runs of this task by providing a `task_run_name`; this setting accepts a string 
that optionally contains templated references to the keyword arguments of your task. The name is 
formatted using Python's standard string formatting syntax:

```python
import datetime
from prefect import flow, task

@task(name="My Example Task", 
      description="An example task for a tutorial.",
      task_run_name="hello-{name}-on-{date:%A}")
def my_task(name, date):
    pass

@flow
def my_flow():
    # creates a run with a name like "hello-marvin-on-Thursday"
    my_task(name="marvin", date=datetime.datetime.now(datetime.timezone.utc))
```

Additionally this setting accepts a function that returns a string for the task run name:

```python
import datetime
from prefect import flow, task

def generate_task_name():
    date = datetime.datetime.now(datetime.timezone.utc)
    return f"{date:%A}-is-a-lovely-day"

@task(name="My Example Task",
      description="An example task for a tutorial.",
      task_run_name=generate_task_name)
def my_task(name):
    pass

@flow
def my_flow():
    # creates a run with a name like "Thursday-is-a-lovely-day"
    my_task(name="marvin")
```

If you need access to information about the task, use the `prefect.runtime` module. For example:

```python
from prefect import flow
from prefect.runtime import flow_run, task_run

def generate_task_name():
    flow_name = flow_run.flow_name
    task_name = task_run.task_name

    parameters = task_run.parameters
    name = parameters["name"]
    limit = parameters["limit"]

    return f"{flow_name}-{task_name}-with-{name}-and-{limit}"

@task(name="my-example-task",
      description="An example task for a tutorial.",
      task_run_name=generate_task_name)
def my_task(name: str, limit: int = 100):
    pass

@flow
def my_flow(name: str):
    # creates a run with a name like "my-flow-my-example-task-with-marvin-and-100"
    my_task(name="marvin")
```

## Tags

Tags are optional string labels that enable you to identify and group tasks other than by name or flow. 
Tags are useful to:

- Filter task runs by tag in the UI and through the [Prefect REST API](/3.0rc/api-ref/rest-api/#filtering).
- Set [concurrency limits](#task-run-concurrency-limits) on task runs by tag.

You may specify tags as a keyword argument on the [task decorator](/3.0rc/api-ref/prefect/tasks/#prefect.tasks.task).

```python hl_lines="1"
@task(name="hello-task", tags=["test"])
def my_task():
    print("Hello, I'm a task")
```

You can also provide tags as an argument with a 
[`tags` context manager](/3.0rc/api-ref/prefect/context/#prefect.context.tags), 
specifying tags when the task is called rather than in its definition.

```python hl_lines="10"
from prefect import flow, task
from prefect import tags

@task
def my_task():
    print("Hello, I'm a task")

@flow
def my_flow():
    with tags("test"):
        my_task()
```

## Caching

Tasks support the ability to cache their return value.
Caching allows you to efficiently reuse [results](/3.0rc/develop/interact-with-data/) of tasks that may be 
expensive to reproduce with every flow run. You can also reuse cached results if the inputs to a task have 
not changed.

Define a task that is cached based on its inputs by using the Prefect 
[`task_input_hash`](/3.0rc/api-ref/prefect/tasks/#prefect.tasks.task_input_hash).

<Warning>
**Task results and caching** 

Task results are cached in memory during a flow run and persisted to your home directory by default. 
Prefect Cloud only stores the cache key, not the data itself.
</Warning>

Caching refers to the ability of a task run to reflect a finished state without actually running the 
code that defines the task. This allows you to efficiently reuse results of tasks that may be expensive 
to run with every flow run, or reuse cached results if the inputs to a task have not changed.

### Cache keys

To determine whether a task run should retrieve a cached state, we use "cache keys". A cache key is a 
string value that indicates if one run should be considered identical to another. When a task run with a 
cache key finishes, we attach that cache key to the state. When each task run starts, Prefect checks for 
states with a matching cache key. If a state with an identical key is found, Prefect uses the cached 
state instead of running the task again.

### Enable caching

To enable caching, specify a `cache_key_fn` on your task. This is a function that returns a cache key. 
You may optionally provide a `cache_expiration` timedelta indicating when the cache expires. If you 
do not specify a `cache_expiration`, the cache key does not expire.

### Take input hash

You can define a task that is cached based on its inputs by using the Prefect `task_input_hash`. This is a 
task cache key implementation that hashes all inputs to the task using a JSON or cloudpickle serializer. If 
the task inputs do not change, it uses the cached results rather than running the task until the cache expires.

Note that if any arguments are not JSON serializable, the pickle serializer is used as a fallback. If 
cloudpickle fails, `task_input_hash` returns a null key indicating that a cache key could not be generated 
for the given inputs.

### Caching example

In this example, until the `cache_expiration` time ends, as long as the input to `hello_task()` remains 
the same when it is called, the cached return value is returned. In this situation the task is not rerun. 
However, if the input argument value changes, `hello_task()` runs using the new input.

```python hl_lines="3 5"
from datetime import timedelta
from prefect import flow, task
from prefect.tasks import task_input_hash

@task(cache_key_fn=task_input_hash, cache_expiration=timedelta(days=1))
def hello_task(name_input):
    # Doing some work
    print("Saying hello")
    return "hello " + name_input

@flow(log_prints=True)
def hello_flow(name_input):
    hello_task(name_input)
```

Alternatively, you can provide your own function or other callable that returns a string cache key. 
A generic `cache_key_fn` is a function that accepts two positional arguments:

- The first argument corresponds to the `TaskRunContext`, which stores task run metadata in the attributes 
`task_run_id`, `flow_run_id`, and `task`.
- The second argument corresponds to a dictionary of input values to the task. For example, if your task is 
defined with signature `fn(x, y, z)` then the dictionary will have keys `"x"`, `"y"`, and `"z"` with 
corresponding values that can be used to compute your cache key.

Note that the `cache_key_fn` is _not_ defined as a `@task`.

<Note>
**Task cache keys**

By default, a task cache key is limited to 2000 characters, specified by the 
`PREFECT_API_TASK_CACHE_KEY_MAX_LENGTH` setting.
</Note>

```python hl_lines="3-5 7"
from prefect import task, flow

def static_cache_key(context, parameters):
    # return a constant
    return "static cache key"

@task(cache_key_fn=static_cache_key)
def cached_task():
    print('running an expensive operation')
    return 42

@flow
def test_caching():
    cached_task()
    cached_task()
    cached_task()
```

In this case, there's no expiration for the cache key, and no logic to change the cache key, so `cached_task()` 
only runs once.

<div class="terminal">
```bash hl_lines="2"
>>> test_caching()
running an expensive operation
>>> test_caching()
>>> test_caching()
```
</div>

When each task run requested to enter a `Running` state, it provides its cache key computed from the `cache_key_fn`. 
The Prefect backend identified that there was a COMPLETED state associated with this key and instructed the run to 
immediately enter the same COMPLETED state, including the same return values.  

A real-world example might include the flow run id from the context in the cache key, so only repeated 
calls in the same flow run are cached:

```python
def cache_within_flow_run(context, parameters):
    return f"{context.task_run.flow_run_id}-{task_input_hash(context, parameters)}"

@task(cache_key_fn=cache_within_flow_run)
def cached_task():
    print('running an expensive operation')
    return 42
```

<Note>
**Task results, retries, and caching**

Task results are cached in memory during a flow run and persisted to the location specified by the 
`PREFECT_LOCAL_STORAGE_PATH` setting. As a result, task caching between flow runs is currently limited 
to flow runs with access to that local storage path.
</Note>

### Refresh the cache

A cache "refresh" means to update the data associated with its cache key instead of using the cache. 

The `refresh_cache` option enables this behavior for a specific task:

```python
import random


def static_cache_key(context, parameters):
    # return a constant
    return "static cache key"


@task(cache_key_fn=static_cache_key, refresh_cache=True)
def caching_task():
    return random.random()
```

When this task runs, it _always_ updates the cache key instead of using the cached value. This is 
particularly useful when you have a flow that is responsible for updating the cache.

To refresh the cache for all tasks, use the `PREFECT_TASKS_REFRESH_CACHE` setting. 
Setting `PREFECT_TASKS_REFRESH_CACHE=true` changes the default behavior of all tasks to refresh. 
This is particularly useful to rerun a flow without cached results.

If you have tasks that should not refresh when this setting is enabled, you may explicitly set `refresh_cache` 
to `False`. These tasks will never refresh the cache. If a cache key exists it will be read, not updated. 
If a cache key does _not_ exist yet, these tasks can still write to the cache.

```python
@task(cache_key_fn=static_cache_key, refresh_cache=False)
def caching_task():
    return random.random()
```

## Timeouts

Task timeouts prevent unintentional long-running tasks. When the duration of execution for a 
task exceeds the duration specified in the timeout, a timeout exception is raised and the task is  
marked as failed. In the UI, the task is visibly designated as `TimedOut`. From the perspective of the 
flow, the timed-out task is treated like any other failed task.

Specify timeout durations with the `timeout_seconds` keyword argument:

```python hl_lines="4"
from prefect import task
import time

@task(timeout_seconds=1, log_prints=True)
def show_timeouts():
    print("I will execute")
    time.sleep(5)
    print("I will not execute")
```

## Task results

Depending on how you call tasks, they can return different types of results and optionally engage the use of 
a [task runner](/3.0rc/develop/write-tasks/use-task-runners/).

Any task can return:

- Data‚Ää, such as `int`, `str`, `dict`, `list`. This is the default behavior any time you 
call `your_task()`.
- [`PrefectFuture`](/3.0rc/api-ref/prefect/futures/#prefect.futures.PrefectFuture). This is achieved 
by calling [`your_task.submit()`](/3.0rc/develop/write-tasks/use-task-runners/#using-a-task-runner). 
A `PrefectFuture` contains both _data_ and _State_.
- Prefect [`State`](/3.0rc/api-ref/server/schemas/states/). Anytime you call your task or flow with 
the argument `return_state=True`, it directly returns a state to build custom behavior based 
on a state change you care about, such as task or flow failing or retrying.

To run your task with a [task runner](/3.0rc/develop/write-tasks/use-task-runners/), you must call the task 
with `.submit()`.

See [state returned values](/3.0rc/develop/write-tasks/use-task-runners/#using-results-from-submitted-tasks) 
for examples.

<Tip>
**Task runners are optional**

If you just need the result from a task, call the task from your flow. For most workflows, 
the default behavior of calling a task directly and receiving a result is enough.
</Tip>

## Wait for

To create a dependency between two tasks that do not exchange data, but one needs to wait for the other to 
finish, use the special [`wait_for`](/3.0rc/api-ref/prefect/tasks/#prefect.tasks.Task.submit) keyword argument:

```python
@task
def task_1():
    pass

@task
def task_2():
    pass

@flow
def my_flow():
    x = task_1()

    # task 2 will wait for task_1 to complete
    y = task_2(wait_for=[x])
```

## Map

Prefect provides a `.map()` implementation that automatically creates a task run for each element of its 
input data. Mapped tasks represent the computations of many individual children tasks.

The simplest Prefect map takes a tasks and applies it to each element of its inputs.

```python
from prefect import flow, task

@task
def print_nums(nums):
    for n in nums:
        print(n)

@task
def square_num(num):
    return num**2

@flow
def map_flow(nums):
    print_nums(nums)
    squared_nums = square_num.map(nums) 
    print_nums(squared_nums)

map_flow([1,2,3,5,8,13])
```

Prefect also supports `unmapped` arguments, allowing you to pass static values that don't get mapped over.

```python
from prefect import flow, task

@task
def add_together(x, y):
    return x + y

@flow
def sum_it(numbers, static_value):
    futures = add_together.map(numbers, static_value)
    return futures

sum_it([1, 2, 3], 5)
```

If your static argument is an iterable, wrap it with `unmapped` to tell Prefect to treat it 
as a static value.

```python
from prefect import flow, task, unmapped

@task
def sum_plus(x, static_iterable):
    return x + sum(static_iterable)

@flow
def sum_it(numbers, static_iterable):
    futures = sum_plus.map(numbers, static_iterable)
    return futures

sum_it([4, 5, 6], unmapped([1, 2, 3]))
```

## Async tasks

Prefect supports asynchronous task and flow definitions by default. All of 
[the standard rules of async](https://docs.python.org/3/library/asyncio-task.html) apply:

```python
import asyncio

from prefect import task, flow

@task
async def print_values(values):
    for value in values:
        await asyncio.sleep(1) # yield
        print(value, end=" ")

@flow
async def async_flow():
    await print_values([1, 2])  # runs immediately
    coros = [print_values("abcd"), print_values("6789")]

    # asynchronously gather the tasks
    await asyncio.gather(*coros)

asyncio.run(async_flow())
```

If you are not using `asyncio.gather`, 
calling [`.submit()`](/3.0rc/develop/write-tasks/use-task-runners/#using-a-task-runner) 
is required for asynchronous execution on the `ConcurrentTaskRunner`.


