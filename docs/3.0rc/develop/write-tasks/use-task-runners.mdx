---
title: Task runners
description: Learn how to use the Prefect task runners for parallel or distributed task execution.
---

Task runners enable you to engage specific executors for Prefect tasks, such as for concurrent, parallel, or 
distributed execution of tasks.

Task runners are not required for task execution. If you call a task function directly, the task executes as a 
regular Python function, without a task runner, and produces whatever result is returned by the function.

Calling a task function from within a flow, using the default task settings, executes the function sequentially. 
Execution of the task function blocks execution of the flow until the task completes. This means, by default, calling 
multiple tasks in a flow causes them to run in order. 

You can also use the `.submit()` method on a task function to submit the task to a _task runner_. 
Using a task runner enables you to control whether tasks run sequentially, concurrently, or if you want to 
take advantage of a parallel or distributed execution library such as Dask or Ray.

### `.submit()` method

Using the `.submit()` method to submit a task also causes the task run to return a 
[`PrefectFuture`](/3.0rc/api-ref/prefect/futures/#prefect.futures.PrefectFuture), which is an 
Prefect object that contains both any _data_ returned by the task function; and a 
[`State`](/3.0rc/api-ref/server/schemas/states/), which is a Prefect object indicating the state of the task run.

### Built-in task runners and integrations

Prefect provides the following built-in task runners: 

- [`SequentialTaskRunner`](/3.0rc/api-ref/prefect/task-runners/#prefect.task_runners.SequentialTaskRunner) 
can run tasks sequentially. 
- [`ConcurrentTaskRunner`](/3.0rc/api-ref/prefect/task-runners/#prefect.task_runners.ConcurrentTaskRunner) 
can run tasks concurrently, allowing tasks to switch when blocking on IO. 
Tasks are submitted to a thread pool maintained by `anyio`.

The following Prefect-developed task runners for parallel or distributed task 
execution are available as [integrations](/3.0rc/integrations/catalog/). 

- [`DaskTaskRunner`](https://prefecthq.github.io/prefect-dask/) can run tasks requiring 
parallel execution using [`dask.distributed`](http://distributed.dask.org/). 
- [`RayTaskRunner`](https://prefecthq.github.io/prefect-ray/) can run tasks requiring 
parallel execution using [Ray](https://www.ray.io/).

<Note>
**Concurrency vs. parallelism**

- **Concurrency** refers to a system that can do more than one thing simultaneously, 
but not at the _exact_ same time. Think of concurrent execution as non-blocking: 
within the restrictions of resources available in the execution environment and data dependencies between tasks, 
execution of one task does not block execution of other tasks in a flow.
-  **Parallelism** refers to a system that can do more than one thing at the _exact_ same time. 
Within the restrictions of resources available, parallel execution can run tasks at the same time, 
such as for operations mapped across a dataset.
</Note>

## Use a task runner

You do not need to specify a task runner for a flow unless your tasks require a specific type of execution. 

To configure your flow to use a specific task runner, import a task runner and assign it as an 
argument for the flow when the flow is defined.

<Note>
**Remember to call `.submit()` when using a task runner.**
Make sure you use `.submit()` to run your task with a task runner. 
Calling the task directly, without `.submit()`, from within a flow runs the task sequentially 
instead of using a specified task runner.
</Note>

For example, you can use `ConcurrentTaskRunner` to allow tasks to switch when they would block.

```python hl_lines="2 11"
from prefect import flow, task
from prefect.task_runners import ConcurrentTaskRunner
import time

@task
def stop_at_floor(floor):
    print(f"elevator moving to floor {floor}")
    time.sleep(floor)
    print(f"elevator stops on floor {floor}")

@flow(task_runner=ConcurrentTaskRunner())
def elevator():
    for floor in range(10, 0, -1):
        stop_at_floor.submit(floor)
```

If you specify an uninitialized task runner class, a task runner instance of that type 
is created with the default settings. You can also pass additional configuration parameters 
for task runners that accept parameters, such as [`DaskTaskRunner`](https://prefecthq.github.io/prefect-dask/) 
and [`RayTaskRunner`](https://prefecthq.github.io/prefect-ray/).

<Tip>
**Default task runner**
If you don't specify a task runner for a flow and you call a task with `.submit()` within the flow, 
Prefect uses the default `ConcurrentTaskRunner`.
</Tip>
## Running tasks sequentially

Sometimes, it's useful to force tasks to run sequentially to make it easier to reason about the 
behavior of your program. Switching to the `SequentialTaskRunner` will force submitted tasks to run 
sequentially rather than concurrently.

<Note>
**Synchronous and asynchronous tasks**
The `SequentialTaskRunner` works with both synchronous and asynchronous task functions. 
Asynchronous tasks are Python functions defined using `async def` rather than `def`.
</Note>

The following example demonstrates using the `SequentialTaskRunner` to ensure that tasks run sequentially. 
In the example, the flow `glass_tower` runs the task `stop_at_floor` for floors 1 through 38, in that order.

```python
from prefect import flow, task
from prefect.task_runners import SequentialTaskRunner
import random

@task
def stop_at_floor(floor):
    situation = random.choice(["on fire","clear"])
    print(f"elevator stops on {floor} which is {situation}")

@flow(task_runner=SequentialTaskRunner(),
      name="towering-infernflow",
      )
def glass_tower():
    for floor in range(1, 39):
        stop_at_floor.submit(floor)
    
glass_tower()
```

## Use multiple task runners

Each flow can only have a single task runner, but sometimes you may want a subset of your tasks to run 
using a specific task runner. In this case, you can create [subflows](/3.0rc/develop/write-workflows/#composing-flows) 
for tasks that need to use a different task runner.

For example, you can have a flow (in the example below called `sequential_flow`) that runs its tasks locally 
using the `SequentialTaskRunner`. If you have some tasks that can run more efficiently in parallel on a Dask cluster, 
you can create a subflow (such as `dask_subflow`) to run those tasks using the `DaskTaskRunner`.

```python
from prefect import flow, task
from prefect.task_runners import SequentialTaskRunner
from prefect_dask.task_runners import DaskTaskRunner

@task
def hello_local():
    print("Hello!")

@task
def hello_dask():
    print("Hello from Dask!")

@flow(task_runner=SequentialTaskRunner())
def sequential_flow():
    hello_local.submit()
    dask_subflow()
    hello_local.submit()

@flow(task_runner=DaskTaskRunner())
def dask_subflow():
    hello_dask.submit()

if __name__ == "__main__":
    sequential_flow()
```
<Tip>
**Guarding main**
You should guard the `main` function by using `if __name__ == "__main__"` to avoid issues with parallel processing. 
</Tip>

This script outputs the following logs demonstrating the use of the Dask task runner:

<div class="terminal">
```bash 
120:14:29.785 | INFO    | prefect.engine - Created flow run 'ivory-caiman' for flow 'sequential-flow'
20:14:29.785 | INFO    | Flow run 'ivory-caiman' - Starting 'SequentialTaskRunner'; submitted tasks will be run sequentially...
20:14:29.880 | INFO    | Flow run 'ivory-caiman' - Created task run 'hello_local-7633879f-0' for task 'hello_local'
20:14:29.881 | INFO    | Flow run 'ivory-caiman' - Executing 'hello_local-7633879f-0' immediately...
Hello!
20:14:29.904 | INFO    | Task run 'hello_local-7633879f-0' - Finished in state Completed()
20:14:29.952 | INFO    | Flow run 'ivory-caiman' - Created subflow run 'nimble-sparrow' for flow 'dask-subflow'
20:14:29.953 | INFO    | prefect.task_runner.dask - Creating a new Dask cluster with `distributed.deploy.local.LocalCluster`
20:14:31.862 | INFO    | prefect.task_runner.dask - The Dask dashboard is available at http://127.0.0.1:8787/status
20:14:31.901 | INFO    | Flow run 'nimble-sparrow' - Created task run 'hello_dask-2b96d711-0' for task 'hello_dask'
20:14:32.370 | INFO    | Flow run 'nimble-sparrow' - Submitted task run 'hello_dask-2b96d711-0' for execution.
Hello from Dask!
20:14:33.358 | INFO    | Flow run 'nimble-sparrow' - Finished in state Completed('All states completed.')
20:14:33.368 | INFO    | Flow run 'ivory-caiman' - Created task run 'hello_local-7633879f-1' for task 'hello_local'
20:14:33.368 | INFO    | Flow run 'ivory-caiman' - Executing 'hello_local-7633879f-1' immediately...
Hello!
20:14:33.386 | INFO    | Task run 'hello_local-7633879f-1' - Finished in state Completed()
20:14:33.399 | INFO    | Flow run 'ivory-caiman' - Finished in state Completed('All states completed.')
```
</div>


## Use results from submitted tasks

When you use `.submit()` to submit a task to a task runner, the task runner creates a 
[`PrefectFuture`](/3.0rc/api-ref/prefect/futures/#prefect.futures.PrefectFuture) for access to the state and 
result of the task.

A `PrefectFuture` is an object that provides access to a computation happening in a task runner, 
even if that computation happens on a remote system.

The following example saves the return value of calling `.submit()` on the task `say_hello` to 
the variable `future`, and then prints the type of the variable:

```python
from prefect import flow, task

@task
def say_hello(name):
    return f"Hello {name}!"

@flow
def hello_world():
    future = say_hello.submit("Marvin")
    print(f"variable 'future' is type {type(future)}")

hello_world()
```

When you run this code, you see that the variable `future` is a `PrefectFuture`:

<div class="terminal">
```bash
variable 'future' is type <class 'prefect.futures.PrefectFuture'>
```
</div>

When you pass a future into a task, Prefect waits for the "upstream" task (the one that the future references), 
to reach a final state before starting the downstream task.

This means that the downstream task won't receive the `PrefectFuture` you passed as an argument. 
Instead, the downstream task receives the value that the upstream task returned.

For example:

```python
from prefect import flow, task

@task
def say_hello(name):
    return f"Hello {name}!"

@task
def print_result(result):
    print(type(result))
    print(result)

@flow(name="hello-flow")
def hello_world():
    future = say_hello.submit("Marvin")
    print_result.submit(future)

hello_world()
```

<div class="terminal">
```bash
<class 'str'>
Hello Marvin!
```
</div>

Futures have a few useful methods. For example, you can get the return value of the task run with 
[`.result()`](/3.0rc/api-ref/prefect/futures/#prefect.futures.PrefectFuture.result):

```python
from prefect import flow, task

@task
def my_task():
    return 42

@flow
def my_flow():
    future = my_task.submit()
    result = future.result()
    print(result)

my_flow()
```

The `.result()` method waits for the task to complete before returning the result to the caller. 
If the task run fails, `.result()` will raise the task run's exception. Disable this behavior 
with the `raise_on_failure` option:

```python
from prefect import flow, task

@task
def my_task():
    return "I'm a task!"


@flow
def my_flow():
    future = my_task.submit()
    result = future.result(raise_on_failure=False)
    if future.get_state().is_failed():
        # `result` is an exception! handle accordingly
        ...
    else:
        # `result` is the expected return value of our task
        ...
```

Retrieve the current state of the task run associated with the `PrefectFuture` using 
[`.get_state()`](/3.0rc/api-ref/prefect/futures/#prefect.futures.PrefectFuture.get_state):

```python
@flow
def my_flow():
    future = my_task.submit()
    state = future.get_state()
```

You can also wait for a task to complete by using the [`.wait()`](/3.0rc/api-ref/prefect/futures/#prefect.futures.PrefectFuture.wait) method:

```python
@flow
def my_flow():
    future = my_task.submit()
    final_state = future.wait()
```

You can include a timeout in the `wait` call to perform logic if the task has not finished in a given amount of time:

```python
@flow
def my_flow():
    future = my_task.submit()
    final_state = future.wait(1)  # Wait one second max
    if final_state:
        # Take action if the task is done
        result = final_state.result()
    else:
        ... # Task action if the task is still running
```

You may also use the [`wait_for=[]`](/3.0rc/api-ref/prefect/tasks/#prefect.tasks.Task.submit) parameter 
when calling a task by specifying upstream task dependencies. This enables you to control task execution 
order for tasks that do not share data dependencies.

```python
@task
def task_a():
    pass

@task
def task_b():
    pass

@task
def task_c():
    pass
    
@task
def task_d():
    pass

@flow
def my_flow():
    a = task_a.submit()
    b = task_b.submit()
    # Wait for task_a and task_b to complete
    c = task_c.submit(wait_for=[a, b])
    # task_d will wait for task_c to complete
    # Note: If waiting for one task it must still be in a list.
    d = task_d(wait_for=[c])
```

### When to use `.result()` in flows

The simplest patterns for writing a flow is either only using tasks or only using pure Python functions. 
When you need to mix the two, use `.result()`.

Use only tasks:

```python
from prefect import flow, task

@task
def say_hello(name):
    return f"Hello {name}!"

@task
def say_nice_to_meet_you(hello_greeting):
    return f"{hello_greeting} Nice to meet you :)"

@flow
def hello_world():
    hello = say_hello.submit("Marvin")
    nice_to_meet_you = say_nice_to_meet_you.submit(hello)

hello_world()
```

Use only Python functions:

```python
from prefect import flow, task

def say_hello(name):
    return f"Hello {name}!"

def say_nice_to_meet_you(hello_greeting):
    return f"{hello_greeting} Nice to meet you :)"

@flow
def hello_world():
    # because this is just a Python function, calls will not be tracked
    hello = say_hello("Marvin") 
    nice_to_meet_you = say_nice_to_meet_you(hello)

hello_world()
```

Mix tasks and Python functions:

```python
from prefect import flow, task

def say_hello_extra_nicely_to_marvin(hello): # not a task or flow!
    if hello == "Hello Marvin!":
        return "HI MARVIN!"
    return hello

@task
def say_hello(name):
    return f"Hello {name}!"

@task
def say_nice_to_meet_you(hello_greeting):
    return f"{hello_greeting} Nice to meet you :)"

@flow
def hello_world():
    # run a task and get the result
    hello = say_hello.submit("Marvin").result()

    # not calling a task or flow
    special_greeting = say_hello_extra_nicely_to_marvin(hello)

    # pass our modified greeting back into a task
    nice_to_meet_you = say_nice_to_meet_you.submit(special_greeting)

    print(nice_to_meet_you.result())

hello_world()
```

Note that `.result()` also limits Prefect's ability to track task dependencies. In the "mixed" example above, 
Prefect is unaware that `say_hello` is upstream of `nice_to_meet_you`.


<Note>
**Calling `.result()` is blocking**

When calling `.result()`, note that your flow function must wait until the task run completes 
before continuing.
</Note>

```python
from prefect import flow, task

@task
def say_hello(name):
    return f"Hello {name}!"

@task
def do_important_stuff():
    print("Doing lots of important stuff!")

@flow
def hello_world():
    # blocks until `say_hello` has finished
    result = say_hello.submit("Marvin").result() 
    do_important_stuff.submit()

hello_world()
```

